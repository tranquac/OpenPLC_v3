# 0 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/cpp/libs/src/opendnp3/outstation/EventWriter.cpp"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 0 "<command-line>" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/cpp/libs/src/opendnp3/outstation/EventWriter.cpp"
# 21 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/cpp/libs/src/opendnp3/outstation/EventWriter.cpp"
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/cpp/libs/src/opendnp3/outstation/EventWriter.h" 1
# 24 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/cpp/libs/src/opendnp3/outstation/EventWriter.h"
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/util/Uncopyable.h" 1
# 24 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/util/Uncopyable.h"
namespace openpal
{



class Uncopyable
{
protected:
 Uncopyable() {}
 ~Uncopyable() {}

private:

 Uncopyable(const Uncopyable&) = delete;
 Uncopyable& operator=(const Uncopyable&) = delete;
};

class StaticOnly
{

private:

 StaticOnly() = delete;
 StaticOnly(const StaticOnly&) = delete;
 StaticOnly& operator=(const StaticOnly&) = delete;
};

}
# 25 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/cpp/libs/src/opendnp3/outstation/EventWriter.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/LinkedList.h" 1
# 24 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/LinkedList.h"
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/ArrayView.h" 1
# 24 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/ArrayView.h"
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/HasSize.h" 1
# 24 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/HasSize.h"
namespace openpal
{

template <class SizeType>
class HasSize
{

public:

 HasSize(SizeType size_) : size(size_)
 {}

 SizeType Size() const
 {
  return size;
 }

 bool IsEmpty() const
 {
  return size == 0;
 }

 bool IsNotEmpty() const
 {
  return size != 0;
 }

protected:

 SizeType size;

};

}
# 25 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/ArrayView.h" 2

# 1 "/usr/include/assert.h" 1 3 4
# 35 "/usr/include/assert.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 415 "/usr/include/features.h" 3 4
# 1 "/usr/include/features-time64.h" 1 3 4
# 20 "/usr/include/features-time64.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 21 "/usr/include/features-time64.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 2 3 4
# 22 "/usr/include/features-time64.h" 2 3 4
# 416 "/usr/include/features.h" 2 3 4
# 523 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 730 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 731 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 732 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 524 "/usr/include/features.h" 2 3 4
# 547 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 548 "/usr/include/features.h" 2 3 4
# 36 "/usr/include/assert.h" 2 3 4
# 27 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/ArrayView.h" 2

namespace openpal
{




template <class ValueType, class IndexType>
class ArrayView : public HasSize<IndexType>
{

public:

 static ArrayView<ValueType, IndexType> Empty()
 {
  return ArrayView(nullptr, 0);
 }

 ArrayView(ValueType* start, IndexType aSize) : HasSize<IndexType>(aSize), buffer(start)
 {}

 inline bool Contains(IndexType index) const
 {
  return index < this->size;
 }

 inline bool Contains(IndexType start, IndexType stop) const
 {
  return (start < stop) && Contains(stop);
 }

 inline ValueType& operator[](IndexType index)
 {
  
# 60 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/ArrayView.h" 3 4
 (static_cast<void> (0))
# 60 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/ArrayView.h"
                           ;
  return buffer[index];
 }

 inline const ValueType& operator[](IndexType index) const
 {
  
# 66 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/ArrayView.h" 3 4
 (static_cast<void> (0))
# 66 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/ArrayView.h"
                           ;
  return buffer[index];
 }

 template <class Action>
 void foreach(const Action& action)
 {
  for (IndexType i = 0; i < this->size; ++i)
  {
   action(buffer[i]);
  }
 }

 template <class Action>
 void foreachIndex(const Action& action)
 {
  for (IndexType i = 0; i < this->size; ++i)
  {
   action(buffer[i], i);
  }
 }

private:
 ValueType* buffer;
};



}
# 25 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/LinkedList.h" 2

# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/Array.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/Array.h"
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/Configure.h" 1
# 24 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/Configure.h"
# 1 "/usr/include/c++/15/cstdint" 1 3
# 40 "/usr/include/c++/15/cstdint" 3
# 1 "/usr/include/x86_64-linux-gnu/c++/15/bits/c++config.h" 1 3
# 37 "/usr/include/x86_64-linux-gnu/c++/15/bits/c++config.h" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wvariadic-macros"

#pragma GCC diagnostic ignored "-Wc++11-extensions"
#pragma GCC diagnostic ignored "-Wc++23-extensions"
# 336 "/usr/include/x86_64-linux-gnu/c++/15/bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;


#pragma GCC visibility push(default)


  extern "C++" __attribute__ ((__noreturn__, __always_inline__))
  inline void __terminate() noexcept
  {
    void terminate() noexcept __attribute__ ((__noreturn__,__cold__));
    terminate();
  }
#pragma GCC visibility pop
}
# 369 "/usr/include/x86_64-linux-gnu/c++/15/bits/c++config.h" 3
namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
# 573 "/usr/include/x86_64-linux-gnu/c++/15/bits/c++config.h" 3
namespace std
{
#pragma GCC visibility push(default)




  __attribute__((__always_inline__))
  constexpr inline bool
  __is_constant_evaluated() noexcept
  {





    return __builtin_is_constant_evaluated();



  }
#pragma GCC visibility pop
}
# 617 "/usr/include/x86_64-linux-gnu/c++/15/bits/c++config.h" 3
namespace std
{
#pragma GCC visibility push(default)

  extern "C++" __attribute__ ((__noreturn__)) __attribute__((__cold__))
  void
  __glibcxx_assert_fail
    (const char* __file, int __line, const char* __function,
     const char* __condition)
  noexcept;
#pragma GCC visibility pop
}
# 648 "/usr/include/x86_64-linux-gnu/c++/15/bits/c++config.h" 3
namespace std
{
  __attribute__((__always_inline__,__visibility__("default")))
  inline void
  __glibcxx_assert_fail()
  { }
}
# 727 "/usr/include/x86_64-linux-gnu/c++/15/bits/c++config.h" 3
# 1 "/usr/include/x86_64-linux-gnu/c++/15/bits/os_defines.h" 1 3
# 728 "/usr/include/x86_64-linux-gnu/c++/15/bits/c++config.h" 2 3


# 1 "/usr/include/x86_64-linux-gnu/c++/15/bits/cpu_defines.h" 1 3
# 731 "/usr/include/x86_64-linux-gnu/c++/15/bits/c++config.h" 2 3
# 887 "/usr/include/x86_64-linux-gnu/c++/15/bits/c++config.h" 3
namespace __gnu_cxx
{
  typedef __decltype(0.0bf16) __bfloat16_t;
}
# 953 "/usr/include/x86_64-linux-gnu/c++/15/bits/c++config.h" 3
#pragma GCC diagnostic pop
# 41 "/usr/include/c++/15/cstdint" 2 3






# 1 "/usr/lib/gcc/x86_64-linux-gnu/15/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/x86_64-linux-gnu/15/include/stdint.h" 3 4
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpedantic"
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 2 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 142 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/time64.h" 1 3 4
# 143 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef long int __suseconds64_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 28 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 35 "/usr/include/stdint.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-least.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/stdint-least.h" 3 4
typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;


typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;
# 42 "/usr/include/stdint.h" 2 3 4





typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 60 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 76 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 90 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 12 "/usr/lib/gcc/x86_64-linux-gnu/15/include/stdint.h" 2 3 4
#pragma GCC diagnostic pop
# 48 "/usr/include/c++/15/cstdint" 2 3


namespace std
{

  using ::int8_t;
  using ::int16_t;
  using ::int32_t;
  using ::int64_t;

  using ::int_fast8_t;
  using ::int_fast16_t;
  using ::int_fast32_t;
  using ::int_fast64_t;

  using ::int_least8_t;
  using ::int_least16_t;
  using ::int_least32_t;
  using ::int_least64_t;

  using ::intmax_t;
  using ::intptr_t;

  using ::uint8_t;
  using ::uint16_t;
  using ::uint32_t;
  using ::uint64_t;

  using ::uint_fast8_t;
  using ::uint_fast16_t;
  using ::uint_fast32_t;
  using ::uint_fast64_t;

  using ::uint_least8_t;
  using ::uint_least16_t;
  using ::uint_least32_t;
  using ::uint_least64_t;

  using ::uintmax_t;
  using ::uintptr_t;
# 144 "/usr/include/c++/15/cstdint" 3
}
# 25 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/Configure.h" 2
# 34 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/Configure.h"

# 34 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/Configure.h"
namespace openpal
{
namespace sizes
{

static const uint16_t MAX_ERASURE_SIZE = 12 * sizeof(void*);

}
}
# 78 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/Configure.h"
# 1 "/usr/include/c++/15/new" 1 3
# 43 "/usr/include/c++/15/new" 3
# 1 "/usr/include/c++/15/bits/exception.h" 1 3
# 40 "/usr/include/c++/15/bits/exception.h" 3

# 40 "/usr/include/c++/15/bits/exception.h" 3
extern "C++" {

namespace std __attribute__ ((__visibility__ ("default")))
{
# 61 "/usr/include/c++/15/bits/exception.h" 3
  class exception
  {
  public:
    exception() noexcept { }
    virtual ~exception() noexcept;

    exception(const exception&) = default;
    exception& operator=(const exception&) = default;
    exception(exception&&) = default;
    exception& operator=(exception&&) = default;




    virtual const char*
    what() const noexcept;
  };



}

}
# 44 "/usr/include/c++/15/new" 2 3





# 1 "/usr/include/c++/15/bits/version.h" 1 3
# 50 "/usr/include/c++/15/new" 2 3

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wc++11-extensions"

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }


    bad_alloc(const bad_alloc&) = default;
    bad_alloc& operator=(const bad_alloc&) = default;




    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };


  class bad_array_new_length : public bad_alloc
  {
  public:
    bad_array_new_length() throw() { }



    virtual ~bad_array_new_length() throw();


    virtual const char* what() const throw();
  };






  struct nothrow_t
  {

    explicit nothrow_t() = default;

  };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();



  new_handler get_new_handler() noexcept;

}
# 137 "/usr/include/c++/15/new" 3
[[__nodiscard__]] void* operator new(std::size_t)
 
  __attribute__((__externally_visible__, __malloc__));
[[__nodiscard__]] void* operator new[](std::size_t)
 
  __attribute__((__externally_visible__, __malloc__));
void operator delete(void*) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*) noexcept
  __attribute__((__externally_visible__));

void operator delete(void*, std::size_t)
  noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, std::size_t)
  noexcept
  __attribute__((__externally_visible__));

[[__nodiscard__]] void* operator new(std::size_t, const std::nothrow_t&)
  noexcept
  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
[[__nodiscard__]] void* operator new[](std::size_t, const std::nothrow_t&)
  noexcept
  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
void operator delete(void*, const std::nothrow_t&)
  noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&)
  noexcept
  __attribute__((__externally_visible__));
# 205 "/usr/include/c++/15/new" 3
[[__nodiscard__]] inline
void* operator new(std::size_t, void* __p)
  noexcept
{ return __p; }
[[__nodiscard__]] inline
void* operator new[](std::size_t, void* __p)
  noexcept
{ return __p; }




inline void operator delete (void*, void*)
  noexcept
{ }
inline void operator delete[](void*, void*)
  noexcept
{ }

}

namespace std
{
# 264 "/usr/include/c++/15/new" 3
}

#pragma GCC visibility pop
#pragma GCC diagnostic pop
# 79 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/Configure.h" 2
# 27 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/Array.h" 2


# 1 "/usr/include/assert.h" 1 3 4
# 30 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/Array.h" 2



# 32 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/Array.h"
namespace openpal
{




template <class ValueType, class IndexType>
class Array : public HasSize<IndexType>
{

public:

 Array(IndexType size) :
  HasSize<IndexType>(size),
  buffer(new ValueType[size]())
 {}

 Array() :
  HasSize<IndexType>(0),
  buffer(nullptr)
 {}

 Array(const Array& copy) :
  HasSize<IndexType>(copy.Size()),
  buffer(new ValueType[copy.Size()])
 {
  for(IndexType i = 0; i < copy.Size(); ++i) buffer[i] = copy.buffer[i];
 }

 ArrayView<ValueType, IndexType> ToView() const
 {
  return ArrayView<ValueType, IndexType>(buffer, this->size);
 }

 inline bool Contains(IndexType index) const
 {
  return index < this->size;
 }

 inline ValueType& operator[](IndexType index)
 {
  
# 73 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/Array.h" 3 4
 (static_cast<void> (0))
# 73 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/Array.h"
                           ;
  return buffer[index];
 }

 const ValueType& operator[](IndexType index) const
 {
  
# 79 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/Array.h" 3 4
 (static_cast<void> (0))
# 79 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/Array.h"
                           ;
  return buffer[index];
 }

 template <class Action>
 void foreach(const Action& action) const
 {
  for(IndexType i = 0; i < this->size; ++i) action(buffer[i]);
 }

 template <class Action>
 void foreach(const Action& action)
 {
  for(IndexType i = 0; i < this->size; ++i) action(buffer[i]);
 }

 template <class Action>
 void foreachIndex(const Action& action)
 {
  for(IndexType i = 0; i < this->size; ++i) action(buffer[i], i);
 }


 template <class Action>
 void foreachIndex(const Action& action) const
 {
  for(uint32_t i = 0; i < this->size; ++i) action(buffer[i], i);
 }

 virtual ~Array()
 {
  delete[] buffer;
 }

protected:

 ValueType* buffer;

private:

 Array& operator=(const Array&) = delete;
};

}
# 27 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/LinkedList.h" 2

namespace openpal
{

template <class ValueType>
class ListNode
{
public:
 ListNode() : value(), prev(nullptr), next(nullptr)
 {}

 ValueType value;

private:
 ListNode* prev;
 ListNode* next;

 template <class T, class U>
 friend class LinkedList;

 template <class T>
 friend class LinkedListIterator;
};


template <class ValueType>
class LinkedListIterator
{
public:
 static LinkedListIterator<ValueType> Undefined()
 {
  return LinkedListIterator(nullptr);
 }

 static LinkedListIterator<ValueType> From(ListNode< ValueType>* pStart)
 {
  return LinkedListIterator(pStart);
 }



 bool HasNext() const
 {
  return (pCurrent != nullptr);
 }

 ListNode< ValueType>* Next()
 {
  if (pCurrent == nullptr)
  {
   return nullptr;
  }
  else
  {
   auto pRet = pCurrent;
   pCurrent = pCurrent->next;
   return pRet;
  }
 }

 ListNode< ValueType>* Current()
 {
  return pCurrent;
 }

 ValueType* CurrentValue()
 {
  if (pCurrent)
  {
   return &pCurrent->value;
  }
  else
  {
   return nullptr;
  }
 }

private:

 LinkedListIterator(ListNode< ValueType>* pStart) : pCurrent(pStart)
 {}

 ListNode<ValueType>* pCurrent;
};



template <class ValueType, class IndexType>
class LinkedList : public HasSize<IndexType>
{
public:

 typedef LinkedListIterator<ValueType> Iterator;

 LinkedList(IndexType maxSize) :
  HasSize<IndexType>(0),
  pHead(nullptr),
  pTail(nullptr),
  pFree(nullptr),
  underlying(maxSize)
 {
  Initialize();
 }

 IndexType Capacity() const
 {
  return underlying.Size();
 }

 void Clear()
 {
  if (this->IsNotEmpty())
  {

   this->Link(pTail, pFree);

   pFree = pHead;
   pHead = pTail = nullptr;
   this->size = 0;
  }
 }

 inline ListNode<ValueType>* Head()
 {
  return pHead;
 }

 Iterator Iterate() const
 {
  return Iterator::From(pHead);
 }

 template <class Selector>
 ListNode<ValueType>* FindFirst(Selector select);

 ListNode<ValueType>* Add(const ValueType& value);

 template <class Selector>
 void While(Selector select)
 {
  auto iter = this->Iterate();
  bool result = true;
  while (result && iter.HasNext())
  {
   result = select(iter.Next()->value);
  }
 }

 template <class Selector>
 void Foreach(Selector select)
 {
  auto iter = this->Iterate();
  while (iter.HasNext())
  {
   select(iter.Next()->value);
  }
 }

 template <class Selector>
 ListNode<ValueType>* RemoveFirst(Selector select)
 {
  auto pNode = this->FindFirst(select);
  if (pNode)
  {
   this->Remove(pNode);
  }
  return pNode;
 }

 template <class Selector>
 IndexType RemoveAll(Selector match)
 {
  IndexType count = 0;

  auto iter = this->Iterate();
  auto pCurrent = iter.Next();
  while (pCurrent)
  {
   if (match(pCurrent->value))
   {
    auto pRemoved = pCurrent;
    pCurrent = iter.Next();
    this->Remove(pRemoved);
    ++count;
   }
   else
   {
    pCurrent = iter.Next();
   }
  }

  return count;
 }

 bool Remove(const ValueType& value)
 {
  auto iter = this->Iterate();
  while (iter.HasNext())
  {
   auto pNode = iter.Next();
   if (pNode->value == value)
   {
    this->Remove(pNode);
    return true;
   }
  }
  return false;
 }

 template <class LessThan>
 ListNode<ValueType>* Insert(const ValueType& value, LessThan lt);

 void Remove(ListNode<ValueType>* apNode);

 inline bool IsFull() const;

private:

 ListNode<ValueType>* pHead;
 ListNode<ValueType>* pTail;
 ListNode<ValueType>* pFree;

 Array<ListNode<ValueType>, IndexType> underlying;

 ListNode<ValueType>* Insert(const ValueType& value, ListNode<ValueType>* left, ListNode<ValueType>* right);

 inline static void Link(ListNode<ValueType>* prev, ListNode<ValueType>* next);

 void Initialize();
};

template <class ValueType, class IndexType>
ListNode<ValueType>* LinkedList<ValueType, IndexType>::Add(const ValueType& value)
{
 return this->Insert(value, pTail, nullptr);
}


template <class ValueType, class IndexType>
template <class LessThan>
ListNode<ValueType>* LinkedList<ValueType, IndexType>::Insert(const ValueType& value, LessThan lt)
{
 if (pFree == nullptr)
 {
  return nullptr;
 }
 else
 {
  auto query = [lt, value](const ValueType & v)
  {
   return lt(value, v);
  };
  auto pResult = this->FindFirst(query);
  if (pResult)
  {
   return Insert(value, pResult->prev, pResult);
  }
  else
  {
   return Insert(value, pTail, nullptr);
  }
 }
}

template <class ValueType, class IndexType>
ListNode<ValueType>* LinkedList<ValueType, IndexType>::Insert(const ValueType& value, ListNode<ValueType>* pLeft, ListNode<ValueType>* pRight)
{
 if (pFree == nullptr)
 {
  return nullptr;
 }
 else
 {

  auto pNode = pFree;
  pFree = pFree->next;
  pNode->value = value;
  ++(this->size);

  this->Link(pLeft, pNode);
  this->Link(pNode, pRight);


  if (pLeft == nullptr)
  {
   pHead = pNode;
  }


  if (pRight == nullptr)
  {
   pTail = pNode;
  }

  return pNode;
 }
}

template <class ValueType, class IndexType>
template <class Selector>
ListNode<ValueType>* LinkedList<ValueType, IndexType>::FindFirst(Selector select)
{
 auto iter = this->Iterate();
 while (iter.HasNext())
 {
  auto pNode = iter.Next();
  if (select(pNode->value))
  {
   return pNode;
  }
 }
 return nullptr;
}

template <class ValueType, class IndexType>
void LinkedList<ValueType, IndexType>::Remove(ListNode<ValueType>* apNode)
{
 if(apNode->prev == nullptr)
 {
  if (apNode->next == nullptr)
  {
   pHead = pTail = nullptr;
  }
  else
  {
   pHead = apNode->next;
  }
 }
 else
 {
  if(apNode->next == nullptr) pTail = apNode->prev;
 }


 Link(apNode->prev, apNode->next);


 apNode->next = pFree;
 if(pFree != nullptr) pFree->prev = apNode;
 apNode->prev = nullptr;
 pFree = apNode;
 --(this->size);
}

template <class ValueType, class IndexType>
bool LinkedList<ValueType, IndexType>::IsFull() const
{
 return (pFree == nullptr);
}



template <class ValueType, class IndexType>
void LinkedList<ValueType, IndexType>::Link(ListNode<ValueType>* first, ListNode<ValueType>* second)
{
 if(first) first->next = second;
 if(second) second->prev = first;
}

template <class ValueType, class IndexType>
void LinkedList<ValueType, IndexType>::Initialize()
{
 if(underlying.IsNotEmpty())
 {
  pFree = &underlying[0];
  for(IndexType i = 1; i < underlying.Size(); ++i)
  {
   Link(&underlying[i - 1], &underlying[i]);
  }
 }
}

}
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/cpp/libs/src/opendnp3/outstation/EventWriter.h" 2

# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/app/HeaderWriter.h" 1
# 24 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/app/HeaderWriter.h"
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/app/GroupVariationRecord.h" 1
# 28 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/app/GroupVariationRecord.h"
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/QualifierCode.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/QualifierCode.h"
namespace opendnp3 {




enum class QualifierCode : uint8_t
{
  UINT8_START_STOP = 0x0,
  UINT16_START_STOP = 0x1,
  ALL_OBJECTS = 0x6,
  UINT8_CNT = 0x7,
  UINT16_CNT = 0x8,
  UINT8_CNT_UINT8_INDEX = 0x17,
  UINT16_CNT_UINT16_INDEX = 0x28,
  UINT16_FREE_FORMAT = 0x5B,
  UNDEFINED = 0xFF
};

uint8_t QualifierCodeToType(QualifierCode arg);
QualifierCode QualifierCodeFromType(uint8_t arg);
char const* QualifierCodeToString(QualifierCode arg);

}
# 29 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/app/GroupVariationRecord.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/TimestampMode.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/TimestampMode.h"
namespace opendnp3 {




enum class TimestampMode : uint8_t
{

  SYNCHRONIZED = 1,

  UNSYNCHRONIZED = 2,

  INVALID = 0
};


}
# 30 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/app/GroupVariationRecord.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/GroupVariation.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/GroupVariation.h"
namespace opendnp3 {




enum class GroupVariation : uint16_t
{
  Group1Var0 = 0x100,
  Group1Var1 = 0x101,
  Group1Var2 = 0x102,
  Group2Var0 = 0x200,
  Group2Var1 = 0x201,
  Group2Var2 = 0x202,
  Group2Var3 = 0x203,
  Group3Var0 = 0x300,
  Group3Var1 = 0x301,
  Group3Var2 = 0x302,
  Group4Var0 = 0x400,
  Group4Var1 = 0x401,
  Group4Var2 = 0x402,
  Group4Var3 = 0x403,
  Group10Var0 = 0xA00,
  Group10Var1 = 0xA01,
  Group10Var2 = 0xA02,
  Group11Var0 = 0xB00,
  Group11Var1 = 0xB01,
  Group11Var2 = 0xB02,
  Group12Var0 = 0xC00,
  Group12Var1 = 0xC01,
  Group13Var1 = 0xD01,
  Group13Var2 = 0xD02,
  Group20Var0 = 0x1400,
  Group20Var1 = 0x1401,
  Group20Var2 = 0x1402,
  Group20Var5 = 0x1405,
  Group20Var6 = 0x1406,
  Group21Var0 = 0x1500,
  Group21Var1 = 0x1501,
  Group21Var2 = 0x1502,
  Group21Var5 = 0x1505,
  Group21Var6 = 0x1506,
  Group21Var9 = 0x1509,
  Group21Var10 = 0x150A,
  Group22Var0 = 0x1600,
  Group22Var1 = 0x1601,
  Group22Var2 = 0x1602,
  Group22Var5 = 0x1605,
  Group22Var6 = 0x1606,
  Group23Var0 = 0x1700,
  Group23Var1 = 0x1701,
  Group23Var2 = 0x1702,
  Group23Var5 = 0x1705,
  Group23Var6 = 0x1706,
  Group30Var0 = 0x1E00,
  Group30Var1 = 0x1E01,
  Group30Var2 = 0x1E02,
  Group30Var3 = 0x1E03,
  Group30Var4 = 0x1E04,
  Group30Var5 = 0x1E05,
  Group30Var6 = 0x1E06,
  Group32Var0 = 0x2000,
  Group32Var1 = 0x2001,
  Group32Var2 = 0x2002,
  Group32Var3 = 0x2003,
  Group32Var4 = 0x2004,
  Group32Var5 = 0x2005,
  Group32Var6 = 0x2006,
  Group32Var7 = 0x2007,
  Group32Var8 = 0x2008,
  Group40Var0 = 0x2800,
  Group40Var1 = 0x2801,
  Group40Var2 = 0x2802,
  Group40Var3 = 0x2803,
  Group40Var4 = 0x2804,
  Group41Var0 = 0x2900,
  Group41Var1 = 0x2901,
  Group41Var2 = 0x2902,
  Group41Var3 = 0x2903,
  Group41Var4 = 0x2904,
  Group42Var0 = 0x2A00,
  Group42Var1 = 0x2A01,
  Group42Var2 = 0x2A02,
  Group42Var3 = 0x2A03,
  Group42Var4 = 0x2A04,
  Group42Var5 = 0x2A05,
  Group42Var6 = 0x2A06,
  Group42Var7 = 0x2A07,
  Group42Var8 = 0x2A08,
  Group43Var1 = 0x2B01,
  Group43Var2 = 0x2B02,
  Group43Var3 = 0x2B03,
  Group43Var4 = 0x2B04,
  Group43Var5 = 0x2B05,
  Group43Var6 = 0x2B06,
  Group43Var7 = 0x2B07,
  Group43Var8 = 0x2B08,
  Group50Var1 = 0x3201,
  Group50Var4 = 0x3204,
  Group51Var1 = 0x3301,
  Group51Var2 = 0x3302,
  Group52Var1 = 0x3401,
  Group52Var2 = 0x3402,
  Group60Var1 = 0x3C01,
  Group60Var2 = 0x3C02,
  Group60Var3 = 0x3C03,
  Group60Var4 = 0x3C04,
  Group70Var1 = 0x4601,
  Group70Var2 = 0x4602,
  Group70Var3 = 0x4603,
  Group70Var4 = 0x4604,
  Group70Var5 = 0x4605,
  Group70Var6 = 0x4606,
  Group70Var7 = 0x4607,
  Group70Var8 = 0x4608,
  Group80Var1 = 0x5001,
  Group110Var0 = 0x6E00,
  Group111Var0 = 0x6F00,
  Group112Var0 = 0x7000,
  Group113Var0 = 0x7100,
  Group120Var1 = 0x7801,
  Group120Var2 = 0x7802,
  Group120Var3 = 0x7803,
  Group120Var4 = 0x7804,
  Group120Var5 = 0x7805,
  Group120Var6 = 0x7806,
  Group120Var7 = 0x7807,
  Group120Var8 = 0x7808,
  Group120Var9 = 0x7809,
  Group120Var10 = 0x780A,
  Group120Var11 = 0x780B,
  Group120Var12 = 0x780C,
  Group120Var13 = 0x780D,
  Group120Var14 = 0x780E,
  Group120Var15 = 0x780F,
  Group121Var0 = 0x7900,
  Group121Var1 = 0x7901,
  Group122Var0 = 0x7A00,
  Group122Var1 = 0x7A01,
  Group122Var2 = 0x7A02,
  UNKNOWN = 0xFFFF
};

uint16_t GroupVariationToType(GroupVariation arg);
GroupVariation GroupVariationFromType(uint16_t arg);
char const* GroupVariationToString(GroupVariation arg);

}
# 31 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/app/GroupVariationRecord.h" 2

# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/app/Range.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/app/Range.h"
# 1 "/usr/include/assert.h" 1 3 4
# 27 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/app/Range.h" 2

# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/util/Comparisons.h" 1
# 24 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/util/Comparisons.h"
namespace openpal
{

template <class T>
inline T Min(T a, T b)
{
 return (a < b) ? a : b;
}

template <class T>
inline T Max(T a, T b)
{
 return (a > b) ? a : b;
}

template <class T>
inline T Bounded(T value, T min, T max)
{
 return Min(Max(value, min), max);
}

template <class T>
inline bool WithinLimits(T value, T min, T max)
{
 return (value >= min) && (value <= max);
}

template <class T>
bool FloatEqual(T a, T b, T eapllon = 1e-6)
{
 T diff = a - b;
 if(diff < 0) diff = -diff;
 return diff <= eapllon;
}

}
# 29 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/app/Range.h" 2

namespace opendnp3
{

class Range
{
public:

 static Range From(uint16_t start, uint16_t stop)
 {
  return Range(start, stop);
 }

 static Range Invalid()
 {
  return Range(1, 0);
 }

 Range() : start(1), stop(0)
 {}

 uint32_t Count() const
 {
  return IsValid() ? (static_cast<uint32_t>(stop) - static_cast<uint32_t>(start) + 1) : 0;
 }

 bool Advance()
 {
  if (this->IsValid())
  {
   if (start < stop)
   {
    ++start;
   }
   else
   {

    start = 1;
    stop = 0;
   }

   return true;
  }
  else
  {
   return false;
  }
 }


 Range Intersection(const Range& other) const
 {
  return Range(
             openpal::Max<uint16_t>(start, other.start),
             openpal::Min<uint16_t>(stop, other.stop)
         );
 }


 Range Union(const Range& other) const
 {
  return Range(
             openpal::Min<uint16_t>(start, other.start),
             openpal::Max<uint16_t>(stop, other.stop)
         );
 }

 bool Equals(const Range& other) const
 {
  return (other.start == start) && (other.stop == stop);
 }

 bool IsValid() const
 {
  return start <= stop;
 }

 bool IsOneByte() const
 {
  return IsValid() && (start <= 255) && (stop <= 255);
 }

 uint16_t start;
 uint16_t stop;

private:

 Range(uint16_t index_) :
  start(index_),
  stop(index_)
 {}

 Range(uint16_t start_, uint16_t stop_) :
  start(start_),
  stop(stop_)
 {}
};

}
# 33 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/app/GroupVariationRecord.h" 2


namespace opendnp3
{

enum class GroupVariationType : int
{
 STATIC,
 EVENT,
 OTHER
};

struct EnumAndType
{
 EnumAndType(GroupVariation enumeration_, GroupVariationType type_) :
  enumeration(enumeration_), type(type_)
 {}

 GroupVariation enumeration;
 GroupVariationType type;
};

class GroupVariationRecord
{

public:

 static EnumAndType GetEnumAndType(uint8_t group, uint8_t variation);

 static uint16_t GetGroupVar(uint8_t group, uint8_t variation);

 static GroupVariationRecord GetRecord(uint8_t group, uint8_t variation);

 static GroupVariationType GetType(uint8_t group, uint8_t variation);

 GroupVariationRecord(uint8_t group_, uint8_t variation_, GroupVariation enumeration_, GroupVariationType type_);

 GroupVariationRecord() : enumeration(GroupVariation::UNKNOWN), type(GroupVariationType::OTHER), group(0), variation(0)
 {}

 GroupVariation enumeration;
 GroupVariationType type;
 uint8_t group;
 uint8_t variation;
};

class HeaderRecord : public GroupVariationRecord
{
public:

 HeaderRecord() : qualifier(0), headerIndex(0)
 {}

 HeaderRecord(const GroupVariationRecord& gv, uint8_t qualifier, uint32_t headerIndex);

 QualifierCode GetQualifierCode() const;

 uint8_t qualifier;
 uint32_t headerIndex;
};



class AllObjectsHeader : public HeaderRecord
{
public:

 explicit AllObjectsHeader(const HeaderRecord& record) : HeaderRecord(record)
 {}

};

class CountHeader : public HeaderRecord
{
public:

 CountHeader(const HeaderRecord& record, uint16_t count_) : HeaderRecord(record), count(count_)
 {}

 uint16_t count;
};

class FreeFormatHeader : public HeaderRecord
{
public:

 FreeFormatHeader(const HeaderRecord& record, uint16_t count_) : HeaderRecord(record), count(count_)
 {}

 uint16_t count;
};

class RangeHeader : public HeaderRecord
{
public:

 RangeHeader(const HeaderRecord& record, const Range& range_) : HeaderRecord(record), range(range_)
 {}

 Range range;
};

class PrefixHeader : public HeaderRecord
{
public:

 PrefixHeader(const HeaderRecord& record, uint16_t count_) : HeaderRecord(record), count(count_)
 {}

 uint16_t count;
};

}
# 25 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/app/HeaderWriter.h" 2


# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/app/IVariableLength.h" 1
# 24 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/app/IVariableLength.h"
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/WSlice.h" 1
# 28 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/WSlice.h"
namespace openpal
{

class RSlice;





class WSlice : public HasSize<uint32_t>
{
public:

 static WSlice Empty();

 void SetAllTo(uint8_t value);

 WSlice();
 WSlice(uint8_t* pBuffer, uint32_t size);

 void Clear();

 uint32_t Advance(uint32_t count);

 WSlice Skip(uint32_t count) const;

 RSlice ToRSlice() const;

 operator uint8_t* ()
 {
  return pBuffer;
 };

 operator uint8_t const* () const
 {
  return pBuffer;
 };

private:

 uint8_t* pBuffer;
};


}
# 25 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/app/IVariableLength.h" 2

# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/GroupVariationID.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/GroupVariationID.h"
namespace opendnp3
{


struct GroupVariationID
{
 GroupVariationID() : group(0xFF), variation(0xFF)
 {}

 GroupVariationID(uint8_t aGroup, uint8_t aVariation):
  group(aGroup),
  variation(aVariation)
 {

 }

 uint8_t group;
 uint8_t variation;
};

}
# 27 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/app/IVariableLength.h" 2

namespace opendnp3
{

class IVariableLength
{

public:

 virtual ~IVariableLength() {}

 virtual GroupVariationID InstanceID() const = 0;


 virtual uint32_t Size() const = 0;


 virtual bool Write(openpal::WSlice& dest) const = 0;


 virtual bool Read(const openpal::RSlice& input) = 0;

};

}
# 28 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/app/HeaderWriter.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/app/RangeWriteIterator.h" 1
# 24 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/app/RangeWriteIterator.h"
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/serialization/Format.h" 1
# 24 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/serialization/Format.h"
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/serialization/UInt48Type.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/serialization/UInt48Type.h"
namespace openpal
{

class UInt48Type
{

public:

 explicit UInt48Type(int64_t value) : value(value)
 {}

 UInt48Type() : value(0)
 {}

 operator int64_t() const
 {
  return value;
 }

 int64_t value;
};

}
# 25 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/serialization/Format.h" 2



namespace openpal
{
class Format : private StaticOnly
{
public:

 static bool Write(WSlice& dest, const uint8_t& value);
 static bool Write(WSlice& dest, const uint16_t& value);

 static bool Write(WSlice& dest, const uint32_t& value);
 static bool Write(WSlice& dest, const UInt48Type& value);

 static bool Write(WSlice& dest, const int16_t& value);
 static bool Write(WSlice& dest, const int32_t& value);

 static bool Write(WSlice& dest, const double& value);
 static bool Write(WSlice& dest, const float& value);

 template <typename T, typename... Args>
 static bool Many(WSlice& dest, const T& value, const Args& ... args)
 {
  return Write(dest, value) && Many(dest, args...);
 }

private:

 static bool Many(WSlice& input)
 {
  return true;
 }
};

}
# 25 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/app/RangeWriteIterator.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/serialization/Serializer.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/serialization/Serializer.h"
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/RSlice.h" 1
# 28 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/RSlice.h"
namespace openpal
{

class WSlice;





class RSlice : public HasSize<uint32_t>
{

public:

 static RSlice Empty();

 RSlice();

 RSlice(uint8_t const* pBuffer, uint32_t size);

 void Clear();

 RSlice CopyTo(WSlice&) const;

 RSlice Take(uint32_t count) const;

 RSlice Skip(uint32_t count) const;

 bool Equals(const RSlice& rhs) const;

 void Advance(uint32_t count);

 operator uint8_t const* () const
 {
  return pBuffer;
 };

private:
 uint8_t const* pBuffer;

};

}
# 27 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/serialization/Serializer.h" 2


namespace openpal
{

template <class T>
class Serializer
{
public:

 typedef bool (*ReadFunc)(RSlice& buffer, T& output);
 typedef bool (*WriteFunc)(const T& value, WSlice& buffer);

 Serializer() : size(0), pReadFunc(nullptr), pWriteFunc(nullptr)
 {}

 Serializer(uint32_t size_, ReadFunc pReadFunc_, WriteFunc pWriteFunc_) :
  size(size_), pReadFunc(pReadFunc_), pWriteFunc(pWriteFunc_)
 {}




 uint32_t Size() const
 {
  return size;
 }




 bool Read(RSlice& buffer, T& output) const
 {
  return (*pReadFunc)(buffer, output);
 }




 bool Write(const T& value, WSlice& buffer) const
 {
  return (*pWriteFunc)(value, buffer);
 }

private:

 uint32_t size;
 ReadFunc pReadFunc;
 WriteFunc pWriteFunc;

};

}
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/app/RangeWriteIterator.h" 2

namespace opendnp3
{


template <class IndexType, class WriteType>
class RangeWriteIterator
{
public:

 static RangeWriteIterator Null()
 {
  return RangeWriteIterator();
 }

 RangeWriteIterator() : start(0), count(0), isValid(false), pPosition(nullptr)
 {}

 RangeWriteIterator(typename IndexType::Type start_, const openpal::Serializer<WriteType>& serializer_, openpal::WSlice& position) :
  start(start_),
  serializer(serializer_),
  count(0),
  isValid(position.Size() >= 2 * IndexType::SIZE),
  range(position),
  pPosition(&position)
 {
  if (isValid)
  {
   openpal::Format::Write(range, start);
   pPosition->Advance(2 * IndexType::SIZE);
  }
 }

 ~RangeWriteIterator()
 {
  if (isValid && count > 0)
  {
   auto stop = start + count - 1;
   IndexType::Write(range, static_cast<typename IndexType::Type>(stop));
  }
 }

 bool Write(const WriteType& value)
 {
  if (isValid && (pPosition->Size() >= serializer.Size()) && (count <= IndexType::Max))
  {
   serializer.Write(value, *pPosition);
   ++count;
   return true;
  }
  else
  {
   return false;
  }
 }

 bool IsValid() const
 {
  return isValid;
 }

private:

 typename IndexType::Type start;
 openpal::Serializer<WriteType> serializer;
 uint32_t count;

 bool isValid;

 openpal::WSlice range;
 openpal::WSlice* pPosition;
};

}
# 29 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/app/HeaderWriter.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/app/CountWriteIterator.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/app/CountWriteIterator.h"
namespace opendnp3
{


template <class CountType, class WriteType>
class CountWriteIterator
{
public:

 static CountWriteIterator Null()
 {
  return CountWriteIterator();
 }

 CountWriteIterator() : count(0), isValid(false), pPosition(nullptr)
 {}

 CountWriteIterator(const openpal::Serializer<WriteType>& serializer_, openpal::WSlice& position) :
  count(0),
  serializer(serializer_),
  isValid(position.Size() >= CountType::SIZE),
  countPosition(position),
  pPosition(&position)
 {
  if(isValid)
  {
   position.Advance(CountType::SIZE);
  }
 }

 ~CountWriteIterator()
 {
  if (isValid)
  {
   openpal::Format::Write(countPosition, count);
  }
 }

 bool Write(const WriteType& value)
 {
  if (isValid && (serializer.Size() <= pPosition->Size()) && (count < CountType::Max))
  {
   serializer.Write(value, *this->pPosition);
   ++count;
   return true;
  }
  else
  {
   return false;
  }
 }

 bool IsValid() const
 {
  return isValid;
 }

private:

 typename CountType::Type count;
 openpal::Serializer<WriteType> serializer;

 bool isValid;

 openpal::WSlice countPosition;
 openpal::WSlice* pPosition;
};

}
# 30 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/app/HeaderWriter.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/app/PrefixedWriteIterator.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/app/PrefixedWriteIterator.h"
namespace opendnp3
{


template <class PrefixType, class WriteType>
class PrefixedWriteIterator
{
public:

 static PrefixedWriteIterator Null()
 {
  return PrefixedWriteIterator();
 }

 PrefixedWriteIterator() :
  sizeOfTypePlusIndex(0),
  count(0),
  isValid(false),
  pPosition(nullptr)
 {}

 PrefixedWriteIterator(const openpal::Serializer<WriteType>& serializer_, openpal::WSlice& position) :
  serializer(serializer_),
  sizeOfTypePlusIndex(serializer.Size() + PrefixType::SIZE),
  count(0),
  isValid(position.Size() >= PrefixType::SIZE),
  countPosition(position),
  pPosition(&position)
 {
  if(isValid)
  {
   pPosition->Advance(PrefixType::SIZE);
  }
 }

 ~PrefixedWriteIterator()
 {
  if (isValid)
  {
   PrefixType::Write(countPosition, count);
  }
 }

 bool Write(const WriteType& value, typename PrefixType::Type index)
 {
  if (isValid && (pPosition->Size() >= sizeOfTypePlusIndex))
  {
   PrefixType::WriteBuffer(*pPosition, index);
   serializer.Write(value, *pPosition);
   ++count;
   return true;
  }
  else
  {
   return false;
  }
 }

 bool IsValid() const
 {
  return isValid;
 }

private:

 openpal::Serializer<WriteType> serializer;
 uint32_t sizeOfTypePlusIndex;

 typename PrefixType::Type count;

 bool isValid;

 openpal::WSlice countPosition;
 openpal::WSlice* pPosition;
};

}
# 31 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/app/HeaderWriter.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/app/BitfieldRangeWriteIterator.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/app/BitfieldRangeWriteIterator.h"
namespace opendnp3
{


template <class IndexType>
class BitfieldRangeWriteIterator
{
public:

 static BitfieldRangeWriteIterator Null()
 {
  auto buffer = openpal::WSlice::Empty();
  return BitfieldRangeWriteIterator(0, buffer);
 }

 BitfieldRangeWriteIterator(typename IndexType::Type start_, openpal::WSlice& position_) :
  start(start_),
  count(0),
  maxCount(0),
  isValid(position_.Size() >= (2 * IndexType::SIZE)),
  range(position_),
  pPosition(&position_)
 {
  if(isValid)
  {
   openpal::Format::Write(range, start_);
   pPosition->Advance(2 * IndexType::SIZE);
   maxCount = pPosition->Size() * 8;
  }
 }

 ~BitfieldRangeWriteIterator()
 {
  if (isValid && count > 0)
  {
   typename IndexType::Type stop = start + count - 1;
   openpal::Format::Write(range, stop);

   auto num = count / 8;

   if ((count % 8) > 0)
   {
    ++num;
   }

   pPosition->Advance(num);
  }
 }

 bool Write(bool value)
 {
  if (isValid && count < maxCount)
  {
   auto byte = count / 8;
   auto bit = count % 8;

   if (bit == 0)
   {
    (*pPosition)[byte] = 0;
   }

   if (value)
   {
    (*pPosition)[byte] = ((*pPosition)[byte] | (1 << bit));
   }

   ++count;
   return true;
  }
  else
  {
   return false;
  }
 }

 bool IsValid() const
 {
  return isValid;
 }

private:

 typename IndexType::Type start;
 typename IndexType::Type count;

 uint32_t maxCount;

 bool isValid;

 openpal::WSlice range;
 openpal::WSlice* pPosition;
};

}
# 32 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/app/HeaderWriter.h" 2

# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/app/DNP3Serializer.h" 1
# 28 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/app/DNP3Serializer.h"
namespace opendnp3
{

template <class T>
class DNP3Serializer : public openpal::Serializer<T>
{
public:

 DNP3Serializer(GroupVariationID id_, uint32_t size_, typename openpal::Serializer<T>::ReadFunc pReadFunc_, typename openpal::Serializer<T>::WriteFunc pWriteFunc_) :
  openpal::Serializer<T>(size_, pReadFunc_, pWriteFunc_),
  id(id_)
 {}

 GroupVariationID ID() const
 {
  return id;
 }

private:

 GroupVariationID id;

};

}
# 34 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/app/HeaderWriter.h" 2


# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/Settable.h" 1
# 24 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/container/Settable.h"
namespace openpal
{


template <class T>
class Settable
{
public:

 Settable() : valueIsSet(false)
 {}

 bool IsSet() const
 {
  return valueIsSet;
 }

 bool IsEmpty() const
 {
  return !valueIsSet;
 }

 T Get() const
 {
  return value;
 }

 bool Pop(T& output)
 {
  if (valueIsSet)
  {
   valueIsSet = false;
   output = value;
   return true;
  }
  else
  {
   return false;
  }
 }

 void Clear()
 {
  valueIsSet = false;
 }

 void Set(const T& value_)
 {
  value = value_;
  valueIsSet = true;
 }

 template <class Action>
 bool IsSetAnd(Action action);

 template <class Action>
 void Foreach(Action action);


private:

 bool valueIsSet;
 T value;
};

template <class T>
template <class Action>
bool Settable<T>::IsSetAnd(Action action)
{
 if (valueIsSet)
 {
  return action(value);
 }
 else
 {
  return false;
 }
}

template <class T>
template <class Action>
void Settable<T>::Foreach(Action action)
{
 if (valueIsSet)
 {
  action(value);
 }
}

}
# 37 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/app/HeaderWriter.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/serialization/Serialization.h" 1
# 24 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/serialization/Serialization.h"
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/serialization/UInt48LE.h" 1
# 25 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/serialization/UInt48LE.h"
# 1 "/usr/include/c++/15/cstring" 1 3
# 47 "/usr/include/c++/15/cstring" 3
# 1 "/usr/include/c++/15/bits/version.h" 1 3
# 48 "/usr/include/c++/15/cstring" 2 3
# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4


# 28 "/usr/include/string.h" 3 4
extern "C" {




# 1 "/usr/lib/gcc/x86_64-linux-gnu/15/include/stddef.h" 1 3 4
# 229 "/usr/lib/gcc/x86_64-linux-gnu/15/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 34 "/usr/include/string.h" 2 3 4
# 43 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
    noexcept (true) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__access__ (__write_only__, 1, 4)));




extern void *memset (void *__s, int __c, size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 80 "/usr/include/string.h" 3 4
extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern void *memchr (void *__s, int __c, size_t __n)
      noexcept (true) __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const void *memchr (const void *__s, int __c, size_t __n)
      noexcept (true) __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) void *
memchr (void *__s, int __c, size_t __n) noexcept (true)
{
  return __builtin_memchr (__s, __c, __n);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const void *
memchr (const void *__s, int __c, size_t __n) noexcept (true)
{
  return __builtin_memchr (__s, __c, __n);
}

}
# 115 "/usr/include/string.h" 3 4
extern "C++" void *rawmemchr (void *__s, int __c)
     noexcept (true) __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *rawmemchr (const void *__s, int __c)
     noexcept (true) __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));







extern "C++" void *memrchr (void *__s, int __c, size_t __n)
      noexcept (true) __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)))
      __attribute__ ((__access__ (__read_only__, 1, 3)));
extern "C++" const void *memrchr (const void *__s, int __c, size_t __n)
      noexcept (true) __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)))
      __attribute__ ((__access__ (__read_only__, 1, 3)));
# 141 "/usr/include/string.h" 3 4
extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
    noexcept (true) __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 1, 3)));



# 1 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 173 "/usr/include/string.h" 2 3 4


extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) noexcept (true) __attribute__ ((__nonnull__ (2, 4)))
     __attribute__ ((__access__ (__write_only__, 1, 3)));





extern char *strdup (const char *__s)
     noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 224 "/usr/include/string.h" 3 4
extern "C++"
{
extern char *strchr (char *__s, int __c)
     noexcept (true) __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strchr (const char *__s, int __c)
     noexcept (true) __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
strchr (char *__s, int __c) noexcept (true)
{
  return __builtin_strchr (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
strchr (const char *__s, int __c) noexcept (true)
{
  return __builtin_strchr (__s, __c);
}

}






extern "C++"
{
extern char *strrchr (char *__s, int __c)
     noexcept (true) __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strrchr (const char *__s, int __c)
     noexcept (true) __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
strrchr (char *__s, int __c) noexcept (true)
{
  return __builtin_strrchr (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
strrchr (const char *__s, int __c) noexcept (true)
{
  return __builtin_strrchr (__s, __c);
}

}
# 281 "/usr/include/string.h" 3 4
extern "C++" char *strchrnul (char *__s, int __c)
     noexcept (true) __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const char *strchrnul (const char *__s, int __c)
     noexcept (true) __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 293 "/usr/include/string.h" 3 4
extern size_t strcspn (const char *__s, const char *__reject)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern "C++"
{
extern char *strpbrk (char *__s, const char *__accept)
     noexcept (true) __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strpbrk (const char *__s, const char *__accept)
     noexcept (true) __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
strpbrk (char *__s, const char *__accept) noexcept (true)
{
  return __builtin_strpbrk (__s, __accept);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
strpbrk (const char *__s, const char *__accept) noexcept (true)
{
  return __builtin_strpbrk (__s, __accept);
}

}






extern "C++"
{
extern char *strstr (char *__haystack, const char *__needle)
     noexcept (true) __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strstr (const char *__haystack, const char *__needle)
     noexcept (true) __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
strstr (char *__haystack, const char *__needle) noexcept (true)
{
  return __builtin_strstr (__haystack, __needle);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
strstr (const char *__haystack, const char *__needle) noexcept (true)
{
  return __builtin_strstr (__haystack, __needle);
}

}







extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     noexcept (true) __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     noexcept (true) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     noexcept (true) __attribute__ ((__nonnull__ (2, 3)));





extern "C++" char *strcasestr (char *__haystack, const char *__needle)
     noexcept (true) __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern "C++" const char *strcasestr (const char *__haystack,
         const char *__needle)
     noexcept (true) __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 389 "/usr/include/string.h" 3 4
extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)))
    __attribute__ ((__access__ (__read_only__, 1, 2)))
    __attribute__ ((__access__ (__read_only__, 3, 4)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern size_t strlen (const char *__s)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) noexcept (true);
# 444 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     noexcept (true) __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 2, 3)));




extern const char *strerrordesc_np (int __err) noexcept (true);

extern const char *strerrorname_np (int __err) noexcept (true);





extern char *strerror_l (int __errnum, locale_t __l) noexcept (true);



# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/15/include/stddef.h" 1 3 4
# 24 "/usr/include/strings.h" 2 3 4






extern "C" {



extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1)));



extern "C++"
{
extern char *index (char *__s, int __c)
     noexcept (true) __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *index (const char *__s, int __c)
     noexcept (true) __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
index (char *__s, int __c) noexcept (true)
{
  return __builtin_index (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
index (const char *__s, int __c) noexcept (true)
{
  return __builtin_index (__s, __c);
}

}







extern "C++"
{
extern char *rindex (char *__s, int __c)
     noexcept (true) __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *rindex (const char *__s, int __c)
     noexcept (true) __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
rindex (char *__s, int __c) noexcept (true)
{
  return __builtin_rindex (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
rindex (const char *__s, int __c) noexcept (true)
{
  return __builtin_rindex (__s, __c);
}

}
# 104 "/usr/include/strings.h" 3 4
extern int ffs (int __i) noexcept (true) __attribute__ ((__const__));





extern int ffsl (long int __l) noexcept (true) __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     noexcept (true) __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));


}
# 463 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__write_only__, 1, 2)));



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) noexcept (true);



extern const char *sigabbrev_np (int __sig) noexcept (true);


extern const char *sigdescr_np (int __sig) noexcept (true);



extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern size_t strlcpy (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
  noexcept (true) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__access__ (__write_only__, 1, 3)));



extern size_t strlcat (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
  noexcept (true) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__access__ (__read_write__, 1, 3)));




extern int strverscmp (const char *__s1, const char *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__read_write__, 1, 2)));







extern "C++" char *basename (char *__filename)
     noexcept (true) __asm ("basename") __attribute__ ((__nonnull__ (1)));
extern "C++" const char *basename (const char *__filename)
     noexcept (true) __asm ("basename") __attribute__ ((__nonnull__ (1)));
# 552 "/usr/include/string.h" 3 4
}
# 49 "/usr/include/c++/15/cstring" 2 3
# 74 "/usr/include/c++/15/cstring" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::memchr;
  using ::memcmp;
  using ::memcpy;
  using ::memmove;
  using ::memset;
  using ::strcat;
  using ::strcmp;
  using ::strcoll;
  using ::strcpy;
  using ::strcspn;
  using ::strerror;
  using ::strlen;
  using ::strncat;
  using ::strncmp;
  using ::strncpy;
  using ::strspn;

  using ::strtok;

  using ::strxfrm;
  using ::strchr;
  using ::strpbrk;
  using ::strrchr;
  using ::strstr;
# 127 "/usr/include/c++/15/cstring" 3

}
}
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/serialization/UInt48LE.h" 2

# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/serialization/UInt48Type.h" 1
# 28 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/serialization/UInt48LE.h" 2





# 32 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/serialization/UInt48LE.h"
namespace openpal
{

class UInt48LE
{
public:

 static UInt48Type Read(const uint8_t* data);

 static void Write(uint8_t* data, UInt48Type value);

 inline static UInt48Type ReadBuffer(RSlice& buffer)
 {
  auto ret = Read(buffer);
  buffer.Advance(SIZE);
  return ret;
 }

 static void WriteBuffer(WSlice& buffer, UInt48Type value)
 {
  Write(buffer, value);
  buffer.Advance(SIZE);
 }

 const static int64_t MAX = 281474976710655ULL;
 const static size_t SIZE = 6;
 typedef UInt48Type Type;
};

}
# 25 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/serialization/Serialization.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/serialization/SerializationTemplatesLE.h" 1
# 30 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/serialization/SerializationTemplatesLE.h"
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/util/Limits.h" 1
# 24 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/util/Limits.h"
namespace openpal
{

template <class T>
T MinValue();

template <class T>
T MaxValue();

}
# 31 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/serialization/SerializationTemplatesLE.h" 2

namespace openpal
{

template <class T>
class Bit16LE
{
public:

 static T Read(const uint8_t* data)
 {
  return (static_cast<T>(data[0]) << 0) | (static_cast<T>(data[1]) << 8);
 }

 static void Write(uint8_t* data, T value)
 {
  data[0] = static_cast<uint8_t>(value & 0xFF);
  data[1] = static_cast<uint8_t>((value >> 8) & 0xFF);
 }

 static void WriteBuffer(WSlice& buffer, T aValue)
 {
  Write(buffer, aValue);
  buffer.Advance(SIZE);
 }

 inline static T ReadBuffer(RSlice& arBuffer)
 {
  auto ret = Read(arBuffer);
  arBuffer.Advance(SIZE);
  return ret;
 }

 typedef T Type;

 const static size_t SIZE = sizeof(T);
 const static T Max;
 const static T Min;
};

template <class T>
const T Bit16LE<T>::Max = openpal::MaxValue<T>();

template <class T>
const T Bit16LE<T>::Min = openpal::MinValue<T>();

template <class T>
class Bit32LE
{
public:






 static T Read(const uint8_t* data)
 {
  return (static_cast<T>(data[0]) << 0) |
          (static_cast<T>(data[1]) << 8) |
          (static_cast<T>(data[2]) << 16) |
          (static_cast<T>(data[3]) << 24);
 }

 static void Write(uint8_t* data, T value)
 {
  data[0] = static_cast<uint8_t>(value & 0xFF);
  data[1] = static_cast<uint8_t>((value >> 8) & 0xFF);
  data[2] = static_cast<uint8_t>((value >> 16) & 0xFF);
  data[3] = static_cast<uint8_t>((value >> 24) & 0xFF);
 }

 static void WriteBuffer(WSlice& buffer, T aValue)
 {
  Write(buffer, aValue);
  buffer.Advance(SIZE);
 }

 inline static T ReadBuffer(RSlice& buffer)
 {
  auto ret = Read(buffer);
  buffer.Advance(SIZE);
  return ret;
 }

 typedef T Type;

 const static size_t SIZE = sizeof(T);
 const static T Max;
 const static T Min;
};

template <class T>
const T Bit32LE<T>::Max = openpal::MaxValue<T>();

template <class T>
const T Bit32LE<T>::Min = openpal::MinValue<T>();

}
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/serialization/Serialization.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/serialization/ByteSerialization.h" 1
# 30 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/serialization/ByteSerialization.h"
namespace openpal
{

class UInt8Simple
{
public:

 inline static uint8_t Read(const uint8_t* pStart)
 {
  return (*pStart);
 }

 inline static uint8_t ReadBuffer(RSlice& buffer)
 {
  auto ret = Read(buffer);
  buffer.Advance(SIZE);
  return ret;
 }

 static void WriteBuffer(WSlice& buffer, uint8_t value)
 {
  Write(buffer, value);
  buffer.Advance(SIZE);
 }

 inline static void Write(uint8_t* pStart, uint8_t value)
 {
  *(pStart) = value;
 }

 const static size_t SIZE = 1;
 const static uint8_t Max;
 const static uint8_t Min;

 typedef uint8_t Type;
};

}
# 27 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/serialization/Serialization.h" 2

# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/serialization/SingleFloat.h" 1
# 28 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/serialization/SingleFloat.h"
# 1 "/usr/include/c++/15/cstddef" 1 3
# 52 "/usr/include/c++/15/cstddef" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/15/include/stddef.h" 1 3 4
# 160 "/usr/lib/gcc/x86_64-linux-gnu/15/include/stddef.h" 3 4

# 160 "/usr/lib/gcc/x86_64-linux-gnu/15/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 440 "/usr/lib/gcc/x86_64-linux-gnu/15/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 451 "/usr/lib/gcc/x86_64-linux-gnu/15/include/stddef.h" 3 4
} max_align_t;






  typedef decltype(nullptr) nullptr_t;
# 53 "/usr/include/c++/15/cstddef" 2 3


# 1 "/usr/include/c++/15/bits/version.h" 1 3
# 56 "/usr/include/c++/15/cstddef" 2 3

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpedantic"

extern "C++"
{

namespace std
{

  using ::max_align_t;
}
# 195 "/usr/include/c++/15/cstddef" 3
}

#pragma GCC diagnostic pop
# 29 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/serialization/SingleFloat.h" 2


# 30 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/serialization/SingleFloat.h"
namespace openpal
{

class SingleFloat : private StaticOnly
{
public:

 static_assert(sizeof(float) == 4, "Unexpected size of single float");

 typedef float Type;

 static float ReadBuffer(RSlice& buffer);
 static void WriteBuffer(WSlice& buffer, float value);

 static float Read(const uint8_t* data);
 static void Write(uint8_t* data, float value);

 const static std::size_t SIZE = sizeof(float);
 const static float Max;
 const static float Min;
};

}
# 29 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/serialization/Serialization.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/serialization/DoubleFloat.h" 1
# 30 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/serialization/DoubleFloat.h"
namespace openpal
{

class DoubleFloat : private StaticOnly
{
public:

 static_assert(sizeof(double) == 8, "Unexpected size of double float");

 typedef double Type;

 static double ReadBuffer(RSlice& buffer);
 static void WriteBuffer(WSlice& buffer, double value);

 static double Read(const uint8_t* data);
 static void Write(uint8_t* data, double value);

 const static std::size_t SIZE = sizeof(double);
 const static double Max;
 const static double Min;
};

}
# 30 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/openpal/serialization/Serialization.h" 2

namespace openpal
{

typedef Bit16LE<int16_t> Int16;
typedef Bit16LE<uint16_t> UInt16;
typedef Bit32LE<int32_t> Int32;
typedef Bit32LE<uint32_t> UInt32;
typedef UInt48LE UInt48;
typedef UInt8Simple UInt8;


}
# 38 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/app/HeaderWriter.h" 2

namespace opendnp3
{


class HeaderWriter
{
 friend class APDUWrapper;

public:

 bool WriteHeader(GroupVariationID id, QualifierCode qc);

 template <class IndexType, class WriteType>
 RangeWriteIterator<IndexType, WriteType> IterateOverRange(QualifierCode qc, const DNP3Serializer<WriteType>& serializer, typename IndexType::Type start);

 template <class IndexType>
 bool WriteRangeHeader(QualifierCode qc, GroupVariationID gvId, typename IndexType::Type start, typename IndexType::Type stop);

 template <class IndexType>
 bool WriteCountHeader(QualifierCode qc, GroupVariationID gvId, typename IndexType::Type count);

 template <class CountType, class WriteType>
 CountWriteIterator<CountType, WriteType> IterateOverCount(QualifierCode qc, const DNP3Serializer<WriteType>& serializer);

 template <class IndexType>
 BitfieldRangeWriteIterator<IndexType> IterateOverSingleBitfield(GroupVariationID id, QualifierCode qc, typename IndexType::Type start);

 template <class CountType, class ValueType>
 bool WriteSingleValue(QualifierCode qc, const DNP3Serializer<ValueType>& serializer, const ValueType&);

 bool WriteFreeFormat(const IVariableLength&);

 template <class CountType, class WriteType>
 bool WriteSingleValue(QualifierCode qc, const WriteType&);

 template <class CountType, class ValueType>
 bool WriteSingleIndexedValue(QualifierCode qc, const DNP3Serializer<ValueType>& serializer, const ValueType&, typename CountType::Type index);

 template <class PrefixType, class WriteType>
 PrefixedWriteIterator<PrefixType, WriteType> IterateOverCountWithPrefix(QualifierCode qc, const DNP3Serializer<WriteType>& serializer);

 template <class PrefixType, class WriteType, class CTOType>
 PrefixedWriteIterator<PrefixType, WriteType> IterateOverCountWithPrefixAndCTO(QualifierCode qc, const DNP3Serializer<WriteType>& serializer, const CTOType& cto);



 void Mark();


 bool Rollback();

 uint32_t Remaining() const;

private:

 explicit HeaderWriter(openpal::WSlice* position_);

 bool WriteHeaderWithReserve(GroupVariationID id, QualifierCode qc, uint32_t reserve);

 openpal::WSlice* position;

 openpal::Settable<openpal::WSlice> mark;
};

template <class IndexType>
bool HeaderWriter::WriteRangeHeader(QualifierCode qc, GroupVariationID gvId, typename IndexType::Type start, typename IndexType::Type stop)
{
 if (WriteHeaderWithReserve(gvId, qc, 2 * IndexType::SIZE))
 {
  IndexType::WriteBuffer(*position, start);
  IndexType::WriteBuffer(*position, stop);
  return true;
 }
 else
 {
  return false;
 }
}

template <class IndexType>
bool HeaderWriter::WriteCountHeader(QualifierCode qc, GroupVariationID gvId, typename IndexType::Type count)
{
 if (WriteHeaderWithReserve(gvId, qc, IndexType::SIZE))
 {
  IndexType::WriteBuffer(*position, count);
  return true;
 }
 else
 {
  return false;
 }
}

template <class CountType, class ValueType>
bool HeaderWriter::WriteSingleValue(QualifierCode qc, const DNP3Serializer<ValueType>& serializer, const ValueType& value)
{
 auto reserveSize = CountType::SIZE + serializer.Size();
 if(this->WriteHeaderWithReserve(ValueType::ID, qc, reserveSize))
 {
  CountType::WSlice(*position, 1);
  serializer.Write(value, *position);
  return true;
 }
 else return false;
}

template <class CountType, class WriteType>
bool HeaderWriter::WriteSingleValue(QualifierCode qc, const WriteType& value)
{
 uint32_t reserveSize = CountType::SIZE + WriteType::Size();
 if(this->WriteHeaderWithReserve(WriteType::ID(), qc, reserveSize))
 {
  CountType::WriteBuffer(*position, 1);
  WriteType::Write(value, *position);
  return true;
 }
 else
 {
  return false;
 }
}

template <class CountType, class ValueType>
bool HeaderWriter::WriteSingleIndexedValue(QualifierCode qc, const DNP3Serializer<ValueType>& serializer, const ValueType& value, typename CountType::Type index)
{
 uint32_t reserveSize = 2 * CountType::SIZE + serializer.Size();
 if(this->WriteHeaderWithReserve(serializer.ID(), qc, reserveSize))
 {
  CountType::WriteBuffer(*position, 1);
  CountType::WriteBuffer(*position, index);
  serializer.Write(value, *position);
  return true;
 }
 else return false;
}

template <class IndexType, class WriteType>
RangeWriteIterator<IndexType, WriteType> HeaderWriter::IterateOverRange(QualifierCode qc, const DNP3Serializer<WriteType>& serializer, typename IndexType::Type start)
{
 uint32_t reserveSize = 2 * IndexType::SIZE + serializer.Size();
 if(this->WriteHeaderWithReserve(serializer.ID(), qc, reserveSize))
 {
  return RangeWriteIterator<IndexType, WriteType>(start, serializer, *position);
 }
 else return RangeWriteIterator<IndexType, WriteType>::Null();
}

template <class CountType, class WriteType>
CountWriteIterator<CountType, WriteType> HeaderWriter::IterateOverCount(QualifierCode qc, const DNP3Serializer<WriteType>& serializer)
{
 uint32_t reserveSize = CountType::SIZE + serializer.Size();
 if(this->WriteHeaderWithReserve(serializer.ID(), qc, reserveSize))
 {
  return CountWriteIterator<CountType, WriteType>(serializer, *position);
 }
 else return CountWriteIterator<CountType, WriteType>::Null();
}

template <class IndexType>
BitfieldRangeWriteIterator<IndexType> HeaderWriter::IterateOverSingleBitfield(GroupVariationID id, QualifierCode qc, typename IndexType::Type start)
{
 uint32_t reserveSize = 2 * IndexType::SIZE + 1;
 if (this->WriteHeaderWithReserve(id, qc, reserveSize))
 {
  return BitfieldRangeWriteIterator<IndexType>(start, *position);
 }
 else return BitfieldRangeWriteIterator<IndexType>::Null();
}

template <class PrefixType, class WriteType>
PrefixedWriteIterator<PrefixType, WriteType> HeaderWriter::IterateOverCountWithPrefix(QualifierCode qc, const DNP3Serializer<WriteType>& serializer)
{
 uint32_t reserveSize = 2 * PrefixType::SIZE + serializer.Size();
 if(this->WriteHeaderWithReserve(serializer.ID(), qc, reserveSize))
 {
  return PrefixedWriteIterator<PrefixType, WriteType>(serializer, *position);
 }
 else return PrefixedWriteIterator<PrefixType, WriteType>::Null();
}

template <class PrefixType, class WriteType, class CTOType>
PrefixedWriteIterator<PrefixType, WriteType> HeaderWriter::IterateOverCountWithPrefixAndCTO(QualifierCode qc, const DNP3Serializer<WriteType>& serializer, const CTOType& cto)
{
 this->Mark();
 if (this->WriteSingleValue<openpal::UInt8, CTOType>(QualifierCode::UINT8_CNT, cto))
 {
  auto iter = IterateOverCountWithPrefix<PrefixType, WriteType>(qc, serializer);
  if (!iter.IsValid())
  {

   this->Rollback();
  }
  return iter;
 }
 else
 {
  return PrefixedWriteIterator<PrefixType, WriteType>::Null();
 }
}

}
# 28 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/cpp/libs/src/opendnp3/outstation/EventWriter.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/outstation/SOERecord.h" 1
# 24 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/outstation/SOERecord.h"
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/EventType.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/EventType.h"
namespace opendnp3
{

static const int NUM_OUTSTATION_EVENT_TYPES = 8;

enum class EventType : uint16_t
{
 Binary = 0,
 Analog = 1,
 Counter = 2,
 FrozenCounter = 3,
 DoubleBitBinary = 4,
 BinaryOutputStatus = 5,
 AnalogOutputStatus = 6,
 SecurityStat = 7
};

enum class EventClass : uint8_t
{
 EC1 = 0,
 EC2 = 1,
 EC3 = 2
};

}
# 25 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/outstation/SOERecord.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementTypeSpecs.h" 1
# 24 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementTypeSpecs.h"
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/outstation/MeasurementConfig.h" 1
# 25 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/outstation/MeasurementConfig.h"
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 1
# 24 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h"
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementTypes.h" 1
# 24 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementTypes.h"
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/BaseMeasurementTypes.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/BaseMeasurementTypes.h"
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/DNPTime.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/DNPTime.h"
namespace opendnp3
{

typedef openpal::UInt48Type DNPTime;

}
# 27 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/BaseMeasurementTypes.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/Flags.h" 1
# 24 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/Flags.h"
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/QualityMasks.h" 1
# 24 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/QualityMasks.h"
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/BinaryQuality.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/BinaryQuality.h"
namespace opendnp3 {




enum class BinaryQuality : uint8_t
{

  ONLINE = 0x1,

  RESTART = 0x2,

  COMM_LOST = 0x4,

  REMOTE_FORCED = 0x8,

  LOCAL_FORCED = 0x10,

  CHATTER_FILTER = 0x20,

  RESERVED = 0x40,

  STATE = 0x80
};


}
# 25 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/QualityMasks.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/DoubleBitBinaryQuality.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/DoubleBitBinaryQuality.h"
namespace opendnp3 {




enum class DoubleBitBinaryQuality : uint8_t
{

  ONLINE = 0x1,

  RESTART = 0x2,

  COMM_LOST = 0x4,

  REMOTE_FORCED = 0x8,

  LOCAL_FORCED = 0x10,

  CHATTER_FILTER = 0x20,

  STATE1 = 0x40,

  STATE2 = 0x80
};


}
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/QualityMasks.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/CounterQuality.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/CounterQuality.h"
namespace opendnp3 {




enum class CounterQuality : uint8_t
{

  ONLINE = 0x1,

  RESTART = 0x2,

  COMM_LOST = 0x4,

  REMOTE_FORCED = 0x8,

  LOCAL_FORCED = 0x10,

  ROLLOVER = 0x20,

  DISCONTINUITY = 0x40,

  RESERVED = 0x80
};


}
# 27 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/QualityMasks.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/FrozenCounterQuality.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/FrozenCounterQuality.h"
namespace opendnp3 {




enum class FrozenCounterQuality : uint8_t
{

  ONLINE = 0x1,

  RESTART = 0x2,

  COMM_LOST = 0x4,

  REMOTE_FORCED = 0x8,

  LOCAL_FORCED = 0x10,

  ROLLOVER = 0x20,

  DISCONTINUITY = 0x40,

  RESERVED = 0x80
};


}
# 28 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/QualityMasks.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/AnalogQuality.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/AnalogQuality.h"
namespace opendnp3 {




enum class AnalogQuality : uint8_t
{

  ONLINE = 0x1,

  RESTART = 0x2,

  COMM_LOST = 0x4,

  REMOTE_FORCED = 0x8,

  LOCAL_FORCED = 0x10,

  OVERRANGE = 0x20,

  REFERENCE_ERR = 0x40,

  RESERVED = 0x80
};


}
# 29 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/QualityMasks.h" 2

# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/AnalogOutputStatusQuality.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/AnalogOutputStatusQuality.h"
namespace opendnp3 {




enum class AnalogOutputStatusQuality : uint8_t
{

  ONLINE = 0x1,

  RESTART = 0x2,

  COMM_LOST = 0x4,

  REMOTE_FORCED = 0x8,

  LOCAL_FORCED = 0x10,

  OVERRANGE = 0x20,

  REFERENCE_ERR = 0x40,

  RESERVED = 0x80
};


}
# 31 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/QualityMasks.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/BinaryOutputStatusQuality.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/BinaryOutputStatusQuality.h"
namespace opendnp3 {




enum class BinaryOutputStatusQuality : uint8_t
{

  ONLINE = 0x1,

  RESTART = 0x2,

  COMM_LOST = 0x4,

  REMOTE_FORCED = 0x8,

  LOCAL_FORCED = 0x10,

  RESERVED1 = 0x20,

  RESERVED2 = 0x40,

  STATE = 0x80
};


}
# 32 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/QualityMasks.h" 2

namespace opendnp3
{

template <class T>
inline uint8_t ToUnderlying(T flag)
{
 return static_cast<uint8_t>(flag);
}

}
# 25 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/Flags.h" 2

namespace opendnp3
{




class Flags
{
public:

 Flags() : value(0)
 {}

 Flags(uint8_t value) : value(value)
 {}

 inline bool IsSet(BinaryQuality flag) const
 {
  return IsSetAny(flag);
 }
 inline bool IsSet(AnalogQuality flag) const
 {
  return IsSetAny(flag);
 }
 inline bool IsSet(CounterQuality flag) const
 {
  return IsSetAny(flag);
 }
 inline bool IsSet(FrozenCounterQuality flag) const
 {
  return IsSetAny(flag);
 }
 inline bool IsSet(BinaryOutputStatusQuality flag) const
 {
  return IsSetAny(flag);
 }
 inline bool IsSet(AnalogOutputStatusQuality flag) const
 {
  return IsSetAny(flag);
 }

 inline void Set(BinaryQuality flag)
 {
  SetAny(flag);
 }
 inline void Set(AnalogQuality flag)
 {
  SetAny(flag);
 }
 inline void Set(CounterQuality flag)
 {
  SetAny(flag);
 }
 inline void Set(FrozenCounterQuality flag)
 {
  SetAny(flag);
 }
 inline void Set(BinaryOutputStatusQuality flag)
 {
  SetAny(flag);
 }
 inline void Set(AnalogOutputStatusQuality flag)
 {
  SetAny(flag);
 }

 uint8_t value;

protected:

 template <class T>
 bool IsSetAny(T flag) const
 {
  return (value & static_cast<uint8_t>(flag)) != 0;
 }

 template <class T>
 void SetAny(T flag)
 {
  value |= static_cast<uint8_t>(flag);
 }
};

}
# 28 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/BaseMeasurementTypes.h" 2

namespace opendnp3
{




class Measurement
{
public:

 Flags flags;
 DNPTime time;

protected:

 Measurement()
 {}

 Measurement(Flags flags) : flags(flags)
 {}

 Measurement(Flags flags, DNPTime time) : flags(flags), time(time)
 {}

};



template <class T>
class TypedMeasurement : public Measurement
{
public:

 T value;

 typedef T Type;

protected:

 TypedMeasurement(): Measurement(), value(0) {}
 TypedMeasurement(Flags flags) : Measurement(flags), value(0) {}
 TypedMeasurement(T value, Flags flags) : Measurement(flags), value(value) {}
 TypedMeasurement(T value, Flags flags, DNPTime time) : Measurement(flags, time), value(value) {}
};

}
# 25 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementTypes.h" 2

# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/DoubleBit.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/DoubleBit.h"
namespace opendnp3 {




enum class DoubleBit : uint8_t
{

  INTERMEDIATE = 0x0,

  DETERMINED_OFF = 0x1,

  DETERMINED_ON = 0x2,

  INDETERMINATE = 0x3
};

uint8_t DoubleBitToType(DoubleBit arg);
DoubleBit DoubleBitFromType(uint8_t arg);
char const* DoubleBitToString(DoubleBit arg);

}
# 27 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementTypes.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/IntervalUnits.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/IntervalUnits.h"
namespace opendnp3 {




enum class IntervalUnits : uint8_t
{

  NoRepeat = 0x0,

  Milliseconds = 0x1,

  Seconds = 0x2,

  Minutes = 0x3,

  Hours = 0x4,

  Days = 0x5,

  Weeks = 0x6,

  Months7 = 0x7,

  Months8 = 0x8,

  Months9 = 0x9,

  Seasons = 0xA,

  Undefined = 0x7F
};

uint8_t IntervalUnitsToType(IntervalUnits arg);
IntervalUnits IntervalUnitsFromType(uint8_t arg);
char const* IntervalUnitsToString(IntervalUnits arg);

}
# 28 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementTypes.h" 2

namespace opendnp3
{






class Binary : public TypedMeasurement<bool>
{
public:

 Binary();

 Binary(bool value);

 Binary(Flags flags);

 Binary(Flags flags, DNPTime time);

 Binary(bool value, Flags flags);

 Binary(bool value, Flags flags, DNPTime time);
};





class DoubleBitBinary : public TypedMeasurement<DoubleBit>
{
public:


 DoubleBitBinary();

 DoubleBitBinary(DoubleBit value);

 DoubleBitBinary(Flags flags);

 DoubleBitBinary(Flags flags, DNPTime time);

 DoubleBitBinary(DoubleBit value, Flags flags);

 DoubleBitBinary(DoubleBit value, Flags flags, DNPTime time);

private:

 static const uint8_t ValueMask = 0xC0;
 static const uint8_t QualityMask = 0x3F;

 static DoubleBit GetValue(Flags flags);

 static Flags GetFlags(Flags flags, DoubleBit state);
};







class BinaryOutputStatus : public TypedMeasurement<bool>
{
public:

 BinaryOutputStatus();

 BinaryOutputStatus(bool value);

 BinaryOutputStatus(Flags flags);

 BinaryOutputStatus(Flags flags, DNPTime time);

 BinaryOutputStatus(bool value, Flags flags);

 BinaryOutputStatus(bool value, Flags flags, DNPTime time);

};






class Analog : public TypedMeasurement<double>
{
public:

 Analog();

 Analog(double value);

 Analog(double value, Flags flags);

 Analog(double value, Flags flags, DNPTime time);
};





class Counter : public TypedMeasurement<uint32_t>
{
public:

 Counter();

 Counter(uint32_t value);

 Counter(uint32_t value, Flags flags);

 Counter(uint32_t value, Flags flags, DNPTime time);
};




class FrozenCounter : public TypedMeasurement<uint32_t>
{
public:

 FrozenCounter();

 FrozenCounter(uint32_t value);

 FrozenCounter(uint32_t value, Flags flags);

 FrozenCounter(uint32_t value, Flags flags, DNPTime time);
};





class AnalogOutputStatus : public TypedMeasurement<double>
{
public:

 AnalogOutputStatus();

 AnalogOutputStatus(double value);

 AnalogOutputStatus(double value, Flags flags);

 AnalogOutputStatus(double value, Flags flags, DNPTime time);
};





class TimeAndInterval
{
public:

 TimeAndInterval();

 TimeAndInterval(DNPTime time, uint32_t interval, uint8_t units);

 TimeAndInterval(DNPTime time, uint32_t interval, IntervalUnits units);

 IntervalUnits GetUnitsEnum() const;

 DNPTime time;
 uint32_t interval;
 uint8_t units;
};

}
# 25 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/SecurityStat.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/SecurityStat.h"
namespace opendnp3
{






class SecurityStat
{
public:


 struct Value
 {
  uint16_t assocId;
  uint32_t count;
 };

 SecurityStat();

 SecurityStat(Value value, uint8_t quality, DNPTime time);

 SecurityStat(uint8_t quality, uint16_t assocId, uint32_t count);

 SecurityStat(uint8_t quality, uint16_t assocId, uint32_t count, DNPTime time);

 uint8_t quality;
 Value value;
 DNPTime time;
};

}
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2



# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticBinaryVariation.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticBinaryVariation.h"
namespace opendnp3 {

enum class StaticBinaryVariation : uint8_t
{
  Group1Var1 = 0,
  Group1Var2 = 1
};


}
# 30 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticDoubleBinaryVariation.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticDoubleBinaryVariation.h"
namespace opendnp3 {

enum class StaticDoubleBinaryVariation : uint8_t
{
  Group3Var2 = 0
};


}
# 31 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticBinaryOutputStatusVariation.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticBinaryOutputStatusVariation.h"
namespace opendnp3 {

enum class StaticBinaryOutputStatusVariation : uint8_t
{
  Group10Var2 = 0
};


}
# 32 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticCounterVariation.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticCounterVariation.h"
namespace opendnp3 {

enum class StaticCounterVariation : uint8_t
{
  Group20Var1 = 0,
  Group20Var2 = 1,
  Group20Var5 = 2,
  Group20Var6 = 3
};


}
# 33 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticFrozenCounterVariation.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticFrozenCounterVariation.h"
namespace opendnp3 {

enum class StaticFrozenCounterVariation : uint8_t
{
  Group21Var1 = 0,
  Group21Var2 = 1,
  Group21Var5 = 2,
  Group21Var6 = 3,
  Group21Var9 = 4,
  Group21Var10 = 5
};


}
# 34 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticAnalogVariation.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticAnalogVariation.h"
namespace opendnp3 {

enum class StaticAnalogVariation : uint8_t
{
  Group30Var1 = 0,
  Group30Var2 = 1,
  Group30Var3 = 2,
  Group30Var4 = 3,
  Group30Var5 = 4,
  Group30Var6 = 5
};


}
# 35 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticAnalogOutputStatusVariation.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticAnalogOutputStatusVariation.h"
namespace opendnp3 {

enum class StaticAnalogOutputStatusVariation : uint8_t
{
  Group40Var1 = 0,
  Group40Var2 = 1,
  Group40Var3 = 2,
  Group40Var4 = 3
};


}
# 36 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticTimeAndIntervalVariation.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticTimeAndIntervalVariation.h"
namespace opendnp3 {

enum class StaticTimeAndIntervalVariation : uint8_t
{
  Group50Var4 = 0
};


}
# 37 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticSecurityStatVariation.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticSecurityStatVariation.h"
namespace opendnp3 {

enum class StaticSecurityStatVariation : uint8_t
{
  Group121Var1 = 0
};


}
# 38 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2

# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/EventBinaryVariation.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/EventBinaryVariation.h"
namespace opendnp3 {

enum class EventBinaryVariation : uint8_t
{
  Group2Var1 = 0,
  Group2Var2 = 1,
  Group2Var3 = 2
};


}
# 40 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/EventDoubleBinaryVariation.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/EventDoubleBinaryVariation.h"
namespace opendnp3 {

enum class EventDoubleBinaryVariation : uint8_t
{
  Group4Var1 = 0,
  Group4Var2 = 1,
  Group4Var3 = 2
};


}
# 41 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/EventBinaryOutputStatusVariation.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/EventBinaryOutputStatusVariation.h"
namespace opendnp3 {

enum class EventBinaryOutputStatusVariation : uint8_t
{
  Group11Var1 = 0,
  Group11Var2 = 1
};


}
# 42 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/EventCounterVariation.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/EventCounterVariation.h"
namespace opendnp3 {

enum class EventCounterVariation : uint8_t
{
  Group22Var1 = 0,
  Group22Var2 = 1,
  Group22Var5 = 2,
  Group22Var6 = 3
};


}
# 43 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/EventFrozenCounterVariation.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/EventFrozenCounterVariation.h"
namespace opendnp3 {

enum class EventFrozenCounterVariation : uint8_t
{
  Group23Var1 = 0,
  Group23Var2 = 1,
  Group23Var5 = 2,
  Group23Var6 = 3
};


}
# 44 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/EventAnalogVariation.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/EventAnalogVariation.h"
namespace opendnp3 {

enum class EventAnalogVariation : uint8_t
{
  Group32Var1 = 0,
  Group32Var2 = 1,
  Group32Var3 = 2,
  Group32Var4 = 3,
  Group32Var5 = 4,
  Group32Var6 = 5,
  Group32Var7 = 6,
  Group32Var8 = 7
};


}
# 45 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/EventAnalogOutputStatusVariation.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/EventAnalogOutputStatusVariation.h"
namespace opendnp3 {

enum class EventAnalogOutputStatusVariation : uint8_t
{
  Group42Var1 = 0,
  Group42Var2 = 1,
  Group42Var3 = 2,
  Group42Var4 = 3,
  Group42Var5 = 4,
  Group42Var6 = 5,
  Group42Var7 = 6,
  Group42Var8 = 7
};


}
# 46 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/EventSecurityStatVariation.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/EventSecurityStatVariation.h"
namespace opendnp3 {

enum class EventSecurityStatVariation : uint8_t
{
  Group122Var1 = 0,
  Group122Var2 = 1
};


}
# 47 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2

# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticTypeBitmask.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/StaticTypeBitmask.h"
namespace opendnp3 {




enum class StaticTypeBitmask : uint16_t
{
  BinaryInput = 0x1,
  DoubleBinaryInput = 0x2,
  Counter = 0x4,
  FrozenCounter = 0x8,
  AnalogInput = 0x10,
  BinaryOutputStatus = 0x20,
  AnalogOutputStatus = 0x40,
  TimeAndInterval = 0x80
};


}
# 49 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementInfo.h" 2



namespace opendnp3
{


struct BinaryInfo : private openpal::StaticOnly
{
 typedef Binary meas_t;
 typedef bool value_t;
 typedef EventBinaryVariation event_variation_t;
 typedef StaticBinaryVariation static_variation_t;

 static const EventType EventTypeEnum = EventType::Binary;
 static const StaticTypeBitmask StaticTypeEnum = StaticTypeBitmask::BinaryInput;
 static const event_variation_t DefaultEventVariation = EventBinaryVariation::Group2Var1;
 static const static_variation_t DefaultStaticVariation = StaticBinaryVariation::Group1Var2;
};

struct DoubleBitBinaryInfo : private openpal::StaticOnly
{
 typedef DoubleBitBinary meas_t;
 typedef DoubleBit value_t;
 typedef EventDoubleBinaryVariation event_variation_t;
 typedef StaticDoubleBinaryVariation static_variation_t;

 static const EventType EventTypeEnum = EventType::DoubleBitBinary;
 static const StaticTypeBitmask StaticTypeEnum = StaticTypeBitmask::DoubleBinaryInput;
 static const event_variation_t DefaultEventVariation = EventDoubleBinaryVariation::Group4Var1;
 static const static_variation_t DefaultStaticVariation = StaticDoubleBinaryVariation::Group3Var2;
};

class BinaryOutputStatusInfo : private openpal::StaticOnly
{
public:

 typedef BinaryOutputStatus meas_t;
 typedef bool value_t;
 typedef EventBinaryOutputStatusVariation event_variation_t;
 typedef StaticBinaryOutputStatusVariation static_variation_t;

 static const EventType EventTypeEnum = EventType::BinaryOutputStatus;
 static const StaticTypeBitmask StaticTypeEnum = StaticTypeBitmask::BinaryOutputStatus;
 static const event_variation_t DefaultEventVariation = EventBinaryOutputStatusVariation::Group11Var1;
 static const static_variation_t DefaultStaticVariation = StaticBinaryOutputStatusVariation::Group10Var2;


};


struct AnalogInfo : private openpal::StaticOnly
{
 typedef Analog meas_t;
 typedef double value_t;
 typedef EventAnalogVariation event_variation_t;
 typedef StaticAnalogVariation static_variation_t;

 static const EventType EventTypeEnum = EventType::Analog;
 static const StaticTypeBitmask StaticTypeEnum = StaticTypeBitmask::AnalogInput;
 static const event_variation_t DefaultEventVariation = EventAnalogVariation::Group32Var1;
 static const static_variation_t DefaultStaticVariation = StaticAnalogVariation::Group30Var1;
};

struct CounterInfo : private openpal::StaticOnly
{
 typedef Counter meas_t;
 typedef uint32_t value_t;
 typedef EventCounterVariation event_variation_t;
 typedef StaticCounterVariation static_variation_t;

 static const EventType EventTypeEnum = EventType::Counter;
 static const StaticTypeBitmask StaticTypeEnum = StaticTypeBitmask::Counter;
 static const event_variation_t DefaultEventVariation = EventCounterVariation::Group22Var1;
 static const static_variation_t DefaultStaticVariation = StaticCounterVariation::Group20Var1;
};

struct FrozenCounterInfo : private openpal::StaticOnly
{
 typedef FrozenCounter meas_t;
 typedef uint32_t value_t;
 typedef EventFrozenCounterVariation event_variation_t;
 typedef StaticFrozenCounterVariation static_variation_t;

 static const EventType EventTypeEnum = EventType::FrozenCounter;
 static const StaticTypeBitmask StaticTypeEnum = StaticTypeBitmask::FrozenCounter;
 static const event_variation_t DefaultEventVariation = EventFrozenCounterVariation::Group23Var1;
 static const static_variation_t DefaultStaticVariation = StaticFrozenCounterVariation::Group21Var1;
};

struct AnalogOutputStatusInfo : private openpal::StaticOnly
{
 typedef AnalogOutputStatus meas_t;
 typedef double value_t;
 typedef EventAnalogOutputStatusVariation event_variation_t;
 typedef StaticAnalogOutputStatusVariation static_variation_t;

 static const EventType EventTypeEnum = EventType::AnalogOutputStatus;
 static const StaticTypeBitmask StaticTypeEnum = StaticTypeBitmask::AnalogOutputStatus;
 static const event_variation_t DefaultEventVariation = EventAnalogOutputStatusVariation::Group42Var1;
 static const static_variation_t DefaultStaticVariation = StaticAnalogOutputStatusVariation::Group40Var1;
};

struct TimeAndIntervalInfo : private openpal::StaticOnly
{
 typedef TimeAndInterval meas_t;
 typedef StaticTimeAndIntervalVariation static_variation_t;

 const static StaticTypeBitmask StaticTypeEnum = StaticTypeBitmask::TimeAndInterval;
 const static StaticTimeAndIntervalVariation DefaultStaticVariation = StaticTimeAndIntervalVariation::Group50Var4;
};

struct SecurityStatInfo : private openpal::StaticOnly
{
 typedef SecurityStat meas_t;
 typedef SecurityStat::Value value_t;
 typedef EventSecurityStatVariation event_variation_t;
 typedef StaticSecurityStatVariation static_variation_t;

 const static EventType EventTypeEnum = EventType::SecurityStat;
 const static event_variation_t DefaultEventVariation = EventSecurityStatVariation::Group122Var1;
 const static static_variation_t DefaultStaticVariation = StaticSecurityStatVariation::Group121Var1;
};

}
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/outstation/MeasurementConfig.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/PointClass.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/gen/PointClass.h"
namespace opendnp3 {




enum class PointClass : uint8_t
{

  Class0 = 0x1,

  Class1 = 0x2,

  Class2 = 0x4,

  Class3 = 0x8
};


}
# 27 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/outstation/MeasurementConfig.h" 2

namespace opendnp3
{


struct IndexConfig
{

 uint16_t vIndex = 0;
};


template <class Info>
struct StaticConfig : IndexConfig
{
 typename Info::static_variation_t svariation = Info::DefaultStaticVariation;
};

template <class Info>
struct EventConfig : StaticConfig<Info>
{
 PointClass clazz = PointClass::Class1;
 typename Info::event_variation_t evariation = Info::DefaultEventVariation;
};

template <class Info>
struct DeadbandConfig : EventConfig<Info>
{
 typename Info::value_t deadband = 0;
};

class BinaryConfig : public EventConfig<BinaryInfo> {};
class DoubleBitBinaryConfig : public EventConfig<DoubleBitBinaryInfo> {};
class AnalogConfig : public DeadbandConfig<AnalogInfo> {};
class CounterConfig : public DeadbandConfig<CounterInfo> {};
class FrozenCounterConfig : public DeadbandConfig<FrozenCounterInfo> {};
class BOStatusConfig : public EventConfig<BinaryOutputStatusInfo> {};
class AOStatusConfig : public DeadbandConfig<AnalogOutputStatusInfo> {};
class TimeAndIntervalConfig : public StaticConfig<TimeAndIntervalInfo> {};
class SecurityStatConfig : public IndexConfig {};

}
# 25 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementTypeSpecs.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/EventCells.h" 1
# 27 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/EventCells.h"
namespace opendnp3
{


struct EmptyEventCell
{

};


template <class Spec>
struct EventCellBase
{
 PointClass clazz;
 typename Spec::meas_t lastEvent;
 typename Spec::event_variation_t evariation;

 void SetEventValue(const typename Spec::meas_t& value)
 {
  lastEvent = value;
 }

protected:

 EventCellBase() : clazz(PointClass::Class1), lastEvent(), evariation(Spec::DefaultEventVariation)
 {}
};


template <class Spec>
struct SimpleEventCell : EventCellBase<Spec>
{
 bool IsEvent(const typename Spec::config_t& config, const typename Spec::meas_t& newValue) const
 {
  return Spec::IsEvent(this->lastEvent, newValue);
 }
};


template <class Spec>
struct DeadbandEventCell : SimpleEventCell<Spec>
{
 bool IsEvent(const typename Spec::config_t& config, const typename Spec::meas_t& newValue) const
 {
  return Spec::IsEvent(this->lastEvent, newValue, config.deadband);
 }
};


}
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementTypeSpecs.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/EventTriggers.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/EventTriggers.h"
namespace opendnp3
{
namespace measurements
{
template <class T, class U>
bool IsEvent(const T& val1, const T& val2, T deadband)
{



 U diff = (val2 > val1) ? (static_cast<U>(val2) - static_cast<U>(val1)) : (static_cast<U>(val1) - static_cast<U>(val2));

 return diff > deadband;
}


bool IsEvent(const TypedMeasurement<double>& newMeas, const TypedMeasurement<double>& oldMeas, double deadband);

}
}
# 27 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/include/opendnp3/app/MeasurementTypeSpecs.h" 2

namespace opendnp3
{


struct BinarySpec : public BinaryInfo
{
 typedef BinaryConfig config_t;
 typedef SimpleEventCell<BinarySpec> event_cell_t;

 inline static bool IsQualityOnlineOnly(const Binary& binary)
 {
  return (binary.flags.value & 0b01111111) == static_cast<uint8_t>(BinaryQuality::ONLINE);
 }

 inline static bool IsEvent(const Binary& oldValue, const Binary& newValue)
 {
  return oldValue.flags.value != newValue.flags.value;
 }
};

struct DoubleBitBinarySpec : public DoubleBitBinaryInfo
{
 typedef DoubleBitBinaryConfig config_t;
 typedef SimpleEventCell<DoubleBitBinarySpec> event_cell_t;

 inline static bool IsEvent(const DoubleBitBinary& oldValue, const DoubleBitBinary& newValue)
 {
  return oldValue.flags.value != newValue.flags.value;
 }
};

struct BinaryOutputStatusSpec : public BinaryOutputStatusInfo
{
 typedef BOStatusConfig config_t;
 typedef SimpleEventCell<BinaryOutputStatusSpec> event_cell_t;

 inline static bool IsEvent(const BinaryOutputStatus& oldValue, const BinaryOutputStatus& newValue)
 {
  return oldValue.flags.value != newValue.flags.value;
 }
};


struct AnalogSpec : public AnalogInfo
{
 typedef AnalogConfig config_t;
 typedef DeadbandEventCell<AnalogSpec> event_cell_t;

 inline static bool IsEvent(const Analog& oldValue, const Analog& newValue, double deadband)
 {
  return measurements::IsEvent(newValue, oldValue, deadband);
 }
};

struct CounterSpec : public CounterInfo
{
 typedef CounterConfig config_t;
 typedef DeadbandEventCell<CounterSpec> event_cell_t;

 inline static bool IsEvent(const Counter& oldValue, const Counter& newValue, uint32_t deadband)
 {
  if (oldValue.flags.value != newValue.flags.value)
  {
   return true;
  }
  else
  {
   return measurements::IsEvent<uint32_t, uint64_t>(oldValue.value, newValue.value, deadband);
  }
 }
};

struct FrozenCounterSpec : public FrozenCounterInfo
{
 typedef FrozenCounterConfig config_t;
 typedef DeadbandEventCell<FrozenCounterSpec> event_cell_t;

 inline static bool IsEvent(const FrozenCounter& oldValue, const FrozenCounter& newValue, uint32_t deadband)
 {
  if (oldValue.flags.value != newValue.flags.value)
  {
   return true;
  }
  else
  {
   return measurements::IsEvent<uint32_t, uint64_t>(oldValue.value, newValue.value, deadband);
  }
 }
};

struct AnalogOutputStatusSpec : public AnalogOutputStatusInfo
{
 typedef AOStatusConfig config_t;
 typedef DeadbandEventCell<AnalogOutputStatusSpec> event_cell_t;

 inline static bool IsEvent(const AnalogOutputStatus& oldValue, const AnalogOutputStatus& newValue, double deadband)
 {
  return measurements::IsEvent(newValue, oldValue, deadband);
 }
};

struct TimeAndIntervalSpec : public TimeAndIntervalInfo
{
 typedef TimeAndIntervalConfig config_t;
 typedef EmptyEventCell event_cell_t;
};

struct SecurityStatSpec : public SecurityStatInfo
{
 typedef SecurityStatConfig config_t;
 typedef EmptyEventCell event_cell_t;

 inline static bool IsEvent(const SecurityStat& oldValue, const SecurityStat& newValue, uint32_t deadband)
 {
  if (oldValue.quality != newValue.quality)
  {
   return true;
  }
  else
  {
   return measurements::IsEvent<uint32_t, uint64_t>(oldValue.value.count, newValue.value.count, deadband);
  }
 }
};

}
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/outstation/SOERecord.h" 2





namespace opendnp3
{

template <class Spec>
struct ValueAndVariation
{
 typename Spec::value_t value;
 typename Spec::event_variation_t defaultVariation;
 typename Spec::event_variation_t selectedVariation;

 void SelectDefaultVariation()
 {
  selectedVariation = defaultVariation;
 }
};

template <class ValueType>
struct EventInstance
{
 ValueType value;
 uint16_t index;
};

union EventValue
{
 ValueAndVariation<BinarySpec> binary;
 ValueAndVariation<DoubleBitBinarySpec> doubleBinary;
 ValueAndVariation<BinaryOutputStatusSpec> binaryOutputStatus;
 ValueAndVariation<CounterSpec> counter;
 ValueAndVariation<FrozenCounterSpec> frozenCounter;
 ValueAndVariation<AnalogSpec> analog;
 ValueAndVariation<AnalogOutputStatusSpec> analogOutputStatus;
 ValueAndVariation<SecurityStatSpec> securityStat;
};

class SOERecord
{
public:

 SOERecord();

 SOERecord(const Binary& meas, uint16_t index, EventClass clazz, EventBinaryVariation var);
 SOERecord(const DoubleBitBinary& meas, uint16_t index, EventClass clazz, EventDoubleBinaryVariation var);
 SOERecord(const BinaryOutputStatus& meas, uint16_t index, EventClass clazz, EventBinaryOutputStatusVariation var);
 SOERecord(const Counter& meas, uint16_t index, EventClass clazz, EventCounterVariation var);
 SOERecord(const FrozenCounter& meas, uint16_t index, EventClass clazz, EventFrozenCounterVariation var);
 SOERecord(const Analog& meas, uint16_t index, EventClass clazz, EventAnalogVariation var);
 SOERecord(const AnalogOutputStatus& meas, uint16_t index, EventClass clazz, EventAnalogOutputStatusVariation var);
 SOERecord(const SecurityStat& meas, uint16_t index, EventClass clazz, EventSecurityStatVariation var);

 template <class Spec>
 EventInstance<typename Spec::meas_t> ReadEvent()
 {
  return EventInstance <typename Spec::meas_t>
  {
   typename Spec::meas_t(GetValue<Spec>().value, flags, time), index
  };
 }

 template <class Spec>
 const ValueAndVariation<Spec>& GetValue();

 void SelectDefault();

 void Select(EventBinaryVariation var);
 void Select(EventDoubleBinaryVariation var);
 void Select(EventBinaryOutputStatusVariation var);
 void Select(EventCounterVariation var);
 void Select(EventFrozenCounterVariation var);
 void Select(EventAnalogVariation var);
 void Select(EventAnalogOutputStatusVariation var);
 void Select(EventSecurityStatVariation var);

 EventType type;
 EventClass clazz;
 bool selected;
 bool written;
 void Reset();

 DNPTime GetTime() const
 {
  return time;
 }

private:

 SOERecord(EventType type, EventClass clazz, uint16_t index, DNPTime time, uint8_t flags);



 EventValue value;
 uint16_t index;
 DNPTime time;
 uint8_t flags;

};

}
# 29 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/cpp/libs/src/opendnp3/outstation/EventWriter.h" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/outstation/IEventRecorder.h" 1
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/outstation/IEventRecorder.h"
namespace opendnp3
{

class IEventRecorder
{
public:

 virtual bool HasMoreUnwrittenEvents() const = 0;

 virtual void RecordWritten(EventClass ec, EventType et) = 0;
};

}
# 30 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/cpp/libs/src/opendnp3/outstation/EventWriter.h" 2

namespace opendnp3
{

class EventWriter : openpal::StaticOnly
{
public:

 static bool Write(HeaderWriter& writer, IEventRecorder& recorder, openpal::LinkedListIterator<SOERecord> iterator);

private:

 class Result
 {
 public:

  Result(bool isFragmentFull_, openpal::LinkedListIterator<SOERecord> location_) : isFragmentFull(isFragmentFull_), location(location_)
  {}

  bool isFragmentFull;
  openpal::LinkedListIterator<SOERecord> location;


 private:

  Result() = delete;
 };

 static Result LoadHeader(HeaderWriter& writer, IEventRecorder& recorder, openpal::ListNode<SOERecord>* pLocation);

 static Result LoadHeaderBinary(HeaderWriter& writer, IEventRecorder& recorder, openpal::ListNode<SOERecord>* pLocation);
 static Result LoadHeaderDoubleBinary(HeaderWriter& writer, IEventRecorder& recorder, openpal::ListNode<SOERecord>* pLocation);
 static Result LoadHeaderCounter(HeaderWriter& writer, IEventRecorder& recorder, openpal::ListNode<SOERecord>* pLocation);
 static Result LoadHeaderFrozenCounter(HeaderWriter& writer, IEventRecorder& recorder, openpal::ListNode<SOERecord>* pLocation);
 static Result LoadHeaderAnalog(HeaderWriter& writer, IEventRecorder& recorder, openpal::ListNode<SOERecord>* pLocation);
 static Result LoadHeaderBinaryOutputStatus(HeaderWriter& writer, IEventRecorder& recorder, openpal::ListNode<SOERecord>* pLocation);
 static Result LoadHeaderAnalogOutputStatus(HeaderWriter& writer, IEventRecorder& recorder, openpal::ListNode<SOERecord>* pLocation);
 static Result LoadHeaderSecurityStat(HeaderWriter& writer, IEventRecorder& recorder, openpal::ListNode<SOERecord>* pLocation);

 inline static bool IsWritable(const SOERecord& record)
 {
  return record.selected && !record.written;
 }

 template <class Spec>
 static Result WriteTypeWithSerializer(HeaderWriter& writer, IEventRecorder& recorder, openpal::ListNode<SOERecord>* pLocation, opendnp3::DNP3Serializer<typename Spec::meas_t> serializer, typename Spec::event_variation_t variation)
 {
  auto iter = openpal::LinkedListIterator<SOERecord>::From(pLocation);

  auto header = writer.IterateOverCountWithPrefix<openpal::UInt16, typename Spec::meas_t>(QualifierCode::UINT16_CNT_UINT16_INDEX, serializer);

  openpal::ListNode<SOERecord>* pCurrent = nullptr;

  while (recorder.HasMoreUnwrittenEvents() && (pCurrent = iter.Next()))
  {
   auto& record = pCurrent->value;

   if (IsWritable(record))
   {
    if ((record.type == Spec::EventTypeEnum) && (record.GetValue<Spec>().selectedVariation == variation))
    {
     auto evt = record.ReadEvent<Spec>();
     if (header.Write(evt.value, evt.index))
     {
      record.written = true;
      recorder.RecordWritten(record.clazz, record.type);
     }
     else
     {
      auto location = openpal::LinkedListIterator<SOERecord>::From(pCurrent);
      return Result(true, location);
     }
    }
    else
    {


     break;
    }
   }
  }

  auto location = openpal::LinkedListIterator<SOERecord>::From(pCurrent);
  return Result(false, location);
 }

 template <class Spec, class CTOType>
 static Result WriteCTOTypeWithSerializer(HeaderWriter& writer, IEventRecorder& recorder, openpal::ListNode<SOERecord>* pLocation, opendnp3::DNP3Serializer<typename Spec::meas_t> serializer, typename Spec::event_variation_t variation)
 {
  auto iter = openpal::LinkedListIterator<SOERecord>::From(pLocation);

  CTOType cto;
  cto.time = pLocation->value.GetTime();

  auto header = writer.IterateOverCountWithPrefixAndCTO<openpal::UInt16, typename Spec::meas_t, CTOType>(QualifierCode::UINT16_CNT_UINT16_INDEX, serializer, cto);

  openpal::ListNode<SOERecord>* pCurrent = nullptr;

  while (recorder.HasMoreUnwrittenEvents() && (pCurrent = iter.Next()))
  {
   auto& record = pCurrent->value;

   if (IsWritable(record))
   {
    if ((record.type == Spec::EventTypeEnum) && (record.GetValue<Spec>().selectedVariation == variation))
    {
     if (record.GetTime() < cto.time)
     {

      break;
     }
     else
     {
      auto diff = record.GetTime() - cto.time;
      if (diff > openpal::UInt16::Max)
      {

       break;
      }
      else
      {
       auto evt = record.ReadEvent<Spec>();
       evt.value.time = DNPTime(diff);
       if (header.Write(evt.value, evt.index))
       {
        record.written = true;
        recorder.RecordWritten(record.clazz, record.type);
       }
       else
       {
        auto location = openpal::LinkedListIterator<SOERecord>::From(pCurrent);
        return Result(true, location);
       }
      }
     }
    }
    else
    {

     break;
    }
   }
  }

  auto location = openpal::LinkedListIterator<SOERecord>::From(pCurrent);
  return Result(false, location);
 }

};

}
# 22 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/cpp/libs/src/opendnp3/outstation/EventWriter.cpp" 2

# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/objects/Group2.h" 1
# 31 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/objects/Group2.h"
namespace opendnp3 {


struct Group2Var0
{
  static GroupVariationID ID() { return GroupVariationID(2,0); }
};


struct Group2Var1
{
  static GroupVariationID ID() { return GroupVariationID(2,1); }

  Group2Var1();

  static uint32_t Size() { return 1; }
  static bool Read(openpal::RSlice&, Group2Var1&);
  static bool Write(const Group2Var1&, openpal::WSlice&);

  uint8_t flags;

  typedef Binary Target;
  typedef BinarySpec Spec;
  static bool ReadTarget(openpal::RSlice&, Binary&);
  static bool WriteTarget(const Binary&, openpal::WSlice&);
  static DNP3Serializer<Binary> Inst() { return DNP3Serializer<Binary>(ID(), Size(), &ReadTarget, &WriteTarget); }
};


struct Group2Var2
{
  static GroupVariationID ID() { return GroupVariationID(2,2); }

  Group2Var2();

  static uint32_t Size() { return 7; }
  static bool Read(openpal::RSlice&, Group2Var2&);
  static bool Write(const Group2Var2&, openpal::WSlice&);

  uint8_t flags;
  DNPTime time;

  typedef Binary Target;
  typedef BinarySpec Spec;
  static bool ReadTarget(openpal::RSlice&, Binary&);
  static bool WriteTarget(const Binary&, openpal::WSlice&);
  static DNP3Serializer<Binary> Inst() { return DNP3Serializer<Binary>(ID(), Size(), &ReadTarget, &WriteTarget); }
};


struct Group2Var3
{
  static GroupVariationID ID() { return GroupVariationID(2,3); }

  Group2Var3();

  static uint32_t Size() { return 3; }
  static bool Read(openpal::RSlice&, Group2Var3&);
  static bool Write(const Group2Var3&, openpal::WSlice&);

  uint8_t flags;
  uint16_t time;

  typedef Binary Target;
  typedef BinarySpec Spec;
  static bool ReadTarget(openpal::RSlice&, Binary&);
  static bool WriteTarget(const Binary&, openpal::WSlice&);
  static DNP3Serializer<Binary> Inst() { return DNP3Serializer<Binary>(ID(), Size(), &ReadTarget, &WriteTarget); }
};


}
# 24 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/cpp/libs/src/opendnp3/outstation/EventWriter.cpp" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/objects/Group4.h" 1
# 31 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/objects/Group4.h"
namespace opendnp3 {


struct Group4Var0
{
  static GroupVariationID ID() { return GroupVariationID(4,0); }
};


struct Group4Var1
{
  static GroupVariationID ID() { return GroupVariationID(4,1); }

  Group4Var1();

  static uint32_t Size() { return 1; }
  static bool Read(openpal::RSlice&, Group4Var1&);
  static bool Write(const Group4Var1&, openpal::WSlice&);

  uint8_t flags;

  typedef DoubleBitBinary Target;
  typedef DoubleBitBinarySpec Spec;
  static bool ReadTarget(openpal::RSlice&, DoubleBitBinary&);
  static bool WriteTarget(const DoubleBitBinary&, openpal::WSlice&);
  static DNP3Serializer<DoubleBitBinary> Inst() { return DNP3Serializer<DoubleBitBinary>(ID(), Size(), &ReadTarget, &WriteTarget); }
};


struct Group4Var2
{
  static GroupVariationID ID() { return GroupVariationID(4,2); }

  Group4Var2();

  static uint32_t Size() { return 7; }
  static bool Read(openpal::RSlice&, Group4Var2&);
  static bool Write(const Group4Var2&, openpal::WSlice&);

  uint8_t flags;
  DNPTime time;

  typedef DoubleBitBinary Target;
  typedef DoubleBitBinarySpec Spec;
  static bool ReadTarget(openpal::RSlice&, DoubleBitBinary&);
  static bool WriteTarget(const DoubleBitBinary&, openpal::WSlice&);
  static DNP3Serializer<DoubleBitBinary> Inst() { return DNP3Serializer<DoubleBitBinary>(ID(), Size(), &ReadTarget, &WriteTarget); }
};


struct Group4Var3
{
  static GroupVariationID ID() { return GroupVariationID(4,3); }

  Group4Var3();

  static uint32_t Size() { return 3; }
  static bool Read(openpal::RSlice&, Group4Var3&);
  static bool Write(const Group4Var3&, openpal::WSlice&);

  uint8_t flags;
  uint16_t time;

  typedef DoubleBitBinary Target;
  typedef DoubleBitBinarySpec Spec;
  static bool ReadTarget(openpal::RSlice&, DoubleBitBinary&);
  static bool WriteTarget(const DoubleBitBinary&, openpal::WSlice&);
  static DNP3Serializer<DoubleBitBinary> Inst() { return DNP3Serializer<DoubleBitBinary>(ID(), Size(), &ReadTarget, &WriteTarget); }
};


}
# 25 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/cpp/libs/src/opendnp3/outstation/EventWriter.cpp" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/objects/Group11.h" 1
# 31 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/objects/Group11.h"
namespace opendnp3 {


struct Group11Var0
{
  static GroupVariationID ID() { return GroupVariationID(11,0); }
};


struct Group11Var1
{
  static GroupVariationID ID() { return GroupVariationID(11,1); }

  Group11Var1();

  static uint32_t Size() { return 1; }
  static bool Read(openpal::RSlice&, Group11Var1&);
  static bool Write(const Group11Var1&, openpal::WSlice&);

  uint8_t flags;

  typedef BinaryOutputStatus Target;
  typedef BinaryOutputStatusSpec Spec;
  static bool ReadTarget(openpal::RSlice&, BinaryOutputStatus&);
  static bool WriteTarget(const BinaryOutputStatus&, openpal::WSlice&);
  static DNP3Serializer<BinaryOutputStatus> Inst() { return DNP3Serializer<BinaryOutputStatus>(ID(), Size(), &ReadTarget, &WriteTarget); }
};


struct Group11Var2
{
  static GroupVariationID ID() { return GroupVariationID(11,2); }

  Group11Var2();

  static uint32_t Size() { return 7; }
  static bool Read(openpal::RSlice&, Group11Var2&);
  static bool Write(const Group11Var2&, openpal::WSlice&);

  uint8_t flags;
  DNPTime time;

  typedef BinaryOutputStatus Target;
  typedef BinaryOutputStatusSpec Spec;
  static bool ReadTarget(openpal::RSlice&, BinaryOutputStatus&);
  static bool WriteTarget(const BinaryOutputStatus&, openpal::WSlice&);
  static DNP3Serializer<BinaryOutputStatus> Inst() { return DNP3Serializer<BinaryOutputStatus>(ID(), Size(), &ReadTarget, &WriteTarget); }
};


}
# 26 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/cpp/libs/src/opendnp3/outstation/EventWriter.cpp" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/objects/Group22.h" 1
# 31 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/objects/Group22.h"
namespace opendnp3 {


struct Group22Var0
{
  static GroupVariationID ID() { return GroupVariationID(22,0); }
};


struct Group22Var1
{
  static GroupVariationID ID() { return GroupVariationID(22,1); }

  Group22Var1();

  static uint32_t Size() { return 5; }
  static bool Read(openpal::RSlice&, Group22Var1&);
  static bool Write(const Group22Var1&, openpal::WSlice&);

  typedef uint32_t ValueType;
  uint8_t flags;
  uint32_t value;

  typedef Counter Target;
  typedef CounterSpec Spec;
  static bool ReadTarget(openpal::RSlice&, Counter&);
  static bool WriteTarget(const Counter&, openpal::WSlice&);
  static DNP3Serializer<Counter> Inst() { return DNP3Serializer<Counter>(ID(), Size(), &ReadTarget, &WriteTarget); }
};


struct Group22Var2
{
  static GroupVariationID ID() { return GroupVariationID(22,2); }

  Group22Var2();

  static uint32_t Size() { return 3; }
  static bool Read(openpal::RSlice&, Group22Var2&);
  static bool Write(const Group22Var2&, openpal::WSlice&);

  typedef uint16_t ValueType;
  uint8_t flags;
  uint16_t value;

  typedef Counter Target;
  typedef CounterSpec Spec;
  static bool ReadTarget(openpal::RSlice&, Counter&);
  static bool WriteTarget(const Counter&, openpal::WSlice&);
  static DNP3Serializer<Counter> Inst() { return DNP3Serializer<Counter>(ID(), Size(), &ReadTarget, &WriteTarget); }
};


struct Group22Var5
{
  static GroupVariationID ID() { return GroupVariationID(22,5); }

  Group22Var5();

  static uint32_t Size() { return 11; }
  static bool Read(openpal::RSlice&, Group22Var5&);
  static bool Write(const Group22Var5&, openpal::WSlice&);

  typedef uint32_t ValueType;
  uint8_t flags;
  uint32_t value;
  DNPTime time;

  typedef Counter Target;
  typedef CounterSpec Spec;
  static bool ReadTarget(openpal::RSlice&, Counter&);
  static bool WriteTarget(const Counter&, openpal::WSlice&);
  static DNP3Serializer<Counter> Inst() { return DNP3Serializer<Counter>(ID(), Size(), &ReadTarget, &WriteTarget); }
};


struct Group22Var6
{
  static GroupVariationID ID() { return GroupVariationID(22,6); }

  Group22Var6();

  static uint32_t Size() { return 9; }
  static bool Read(openpal::RSlice&, Group22Var6&);
  static bool Write(const Group22Var6&, openpal::WSlice&);

  typedef uint16_t ValueType;
  uint8_t flags;
  uint16_t value;
  DNPTime time;

  typedef Counter Target;
  typedef CounterSpec Spec;
  static bool ReadTarget(openpal::RSlice&, Counter&);
  static bool WriteTarget(const Counter&, openpal::WSlice&);
  static DNP3Serializer<Counter> Inst() { return DNP3Serializer<Counter>(ID(), Size(), &ReadTarget, &WriteTarget); }
};


}
# 27 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/cpp/libs/src/opendnp3/outstation/EventWriter.cpp" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/objects/Group23.h" 1
# 31 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/objects/Group23.h"
namespace opendnp3 {


struct Group23Var0
{
  static GroupVariationID ID() { return GroupVariationID(23,0); }
};


struct Group23Var1
{
  static GroupVariationID ID() { return GroupVariationID(23,1); }

  Group23Var1();

  static uint32_t Size() { return 5; }
  static bool Read(openpal::RSlice&, Group23Var1&);
  static bool Write(const Group23Var1&, openpal::WSlice&);

  typedef uint32_t ValueType;
  uint8_t flags;
  uint32_t value;

  typedef FrozenCounter Target;
  typedef FrozenCounterSpec Spec;
  static bool ReadTarget(openpal::RSlice&, FrozenCounter&);
  static bool WriteTarget(const FrozenCounter&, openpal::WSlice&);
  static DNP3Serializer<FrozenCounter> Inst() { return DNP3Serializer<FrozenCounter>(ID(), Size(), &ReadTarget, &WriteTarget); }
};


struct Group23Var2
{
  static GroupVariationID ID() { return GroupVariationID(23,2); }

  Group23Var2();

  static uint32_t Size() { return 3; }
  static bool Read(openpal::RSlice&, Group23Var2&);
  static bool Write(const Group23Var2&, openpal::WSlice&);

  typedef uint16_t ValueType;
  uint8_t flags;
  uint16_t value;

  typedef FrozenCounter Target;
  typedef FrozenCounterSpec Spec;
  static bool ReadTarget(openpal::RSlice&, FrozenCounter&);
  static bool WriteTarget(const FrozenCounter&, openpal::WSlice&);
  static DNP3Serializer<FrozenCounter> Inst() { return DNP3Serializer<FrozenCounter>(ID(), Size(), &ReadTarget, &WriteTarget); }
};


struct Group23Var5
{
  static GroupVariationID ID() { return GroupVariationID(23,5); }

  Group23Var5();

  static uint32_t Size() { return 11; }
  static bool Read(openpal::RSlice&, Group23Var5&);
  static bool Write(const Group23Var5&, openpal::WSlice&);

  typedef uint32_t ValueType;
  uint8_t flags;
  uint32_t value;
  DNPTime time;

  typedef FrozenCounter Target;
  typedef FrozenCounterSpec Spec;
  static bool ReadTarget(openpal::RSlice&, FrozenCounter&);
  static bool WriteTarget(const FrozenCounter&, openpal::WSlice&);
  static DNP3Serializer<FrozenCounter> Inst() { return DNP3Serializer<FrozenCounter>(ID(), Size(), &ReadTarget, &WriteTarget); }
};


struct Group23Var6
{
  static GroupVariationID ID() { return GroupVariationID(23,6); }

  Group23Var6();

  static uint32_t Size() { return 9; }
  static bool Read(openpal::RSlice&, Group23Var6&);
  static bool Write(const Group23Var6&, openpal::WSlice&);

  typedef uint16_t ValueType;
  uint8_t flags;
  uint16_t value;
  DNPTime time;

  typedef FrozenCounter Target;
  typedef FrozenCounterSpec Spec;
  static bool ReadTarget(openpal::RSlice&, FrozenCounter&);
  static bool WriteTarget(const FrozenCounter&, openpal::WSlice&);
  static DNP3Serializer<FrozenCounter> Inst() { return DNP3Serializer<FrozenCounter>(ID(), Size(), &ReadTarget, &WriteTarget); }
};


}
# 28 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/cpp/libs/src/opendnp3/outstation/EventWriter.cpp" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/objects/Group32.h" 1
# 31 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/objects/Group32.h"
namespace opendnp3 {


struct Group32Var0
{
  static GroupVariationID ID() { return GroupVariationID(32,0); }
};


struct Group32Var1
{
  static GroupVariationID ID() { return GroupVariationID(32,1); }

  Group32Var1();

  static uint32_t Size() { return 5; }
  static bool Read(openpal::RSlice&, Group32Var1&);
  static bool Write(const Group32Var1&, openpal::WSlice&);

  typedef int32_t ValueType;
  uint8_t flags;
  int32_t value;

  typedef Analog Target;
  typedef AnalogSpec Spec;
  static bool ReadTarget(openpal::RSlice&, Analog&);
  static bool WriteTarget(const Analog&, openpal::WSlice&);
  static DNP3Serializer<Analog> Inst() { return DNP3Serializer<Analog>(ID(), Size(), &ReadTarget, &WriteTarget); }
};


struct Group32Var2
{
  static GroupVariationID ID() { return GroupVariationID(32,2); }

  Group32Var2();

  static uint32_t Size() { return 3; }
  static bool Read(openpal::RSlice&, Group32Var2&);
  static bool Write(const Group32Var2&, openpal::WSlice&);

  typedef int16_t ValueType;
  uint8_t flags;
  int16_t value;

  typedef Analog Target;
  typedef AnalogSpec Spec;
  static bool ReadTarget(openpal::RSlice&, Analog&);
  static bool WriteTarget(const Analog&, openpal::WSlice&);
  static DNP3Serializer<Analog> Inst() { return DNP3Serializer<Analog>(ID(), Size(), &ReadTarget, &WriteTarget); }
};


struct Group32Var3
{
  static GroupVariationID ID() { return GroupVariationID(32,3); }

  Group32Var3();

  static uint32_t Size() { return 11; }
  static bool Read(openpal::RSlice&, Group32Var3&);
  static bool Write(const Group32Var3&, openpal::WSlice&);

  typedef int32_t ValueType;
  uint8_t flags;
  int32_t value;
  DNPTime time;

  typedef Analog Target;
  typedef AnalogSpec Spec;
  static bool ReadTarget(openpal::RSlice&, Analog&);
  static bool WriteTarget(const Analog&, openpal::WSlice&);
  static DNP3Serializer<Analog> Inst() { return DNP3Serializer<Analog>(ID(), Size(), &ReadTarget, &WriteTarget); }
};


struct Group32Var4
{
  static GroupVariationID ID() { return GroupVariationID(32,4); }

  Group32Var4();

  static uint32_t Size() { return 9; }
  static bool Read(openpal::RSlice&, Group32Var4&);
  static bool Write(const Group32Var4&, openpal::WSlice&);

  typedef int16_t ValueType;
  uint8_t flags;
  int16_t value;
  DNPTime time;

  typedef Analog Target;
  typedef AnalogSpec Spec;
  static bool ReadTarget(openpal::RSlice&, Analog&);
  static bool WriteTarget(const Analog&, openpal::WSlice&);
  static DNP3Serializer<Analog> Inst() { return DNP3Serializer<Analog>(ID(), Size(), &ReadTarget, &WriteTarget); }
};


struct Group32Var5
{
  static GroupVariationID ID() { return GroupVariationID(32,5); }

  Group32Var5();

  static uint32_t Size() { return 5; }
  static bool Read(openpal::RSlice&, Group32Var5&);
  static bool Write(const Group32Var5&, openpal::WSlice&);

  typedef float ValueType;
  uint8_t flags;
  float value;

  typedef Analog Target;
  typedef AnalogSpec Spec;
  static bool ReadTarget(openpal::RSlice&, Analog&);
  static bool WriteTarget(const Analog&, openpal::WSlice&);
  static DNP3Serializer<Analog> Inst() { return DNP3Serializer<Analog>(ID(), Size(), &ReadTarget, &WriteTarget); }
};


struct Group32Var6
{
  static GroupVariationID ID() { return GroupVariationID(32,6); }

  Group32Var6();

  static uint32_t Size() { return 9; }
  static bool Read(openpal::RSlice&, Group32Var6&);
  static bool Write(const Group32Var6&, openpal::WSlice&);

  typedef double ValueType;
  uint8_t flags;
  double value;

  typedef Analog Target;
  typedef AnalogSpec Spec;
  static bool ReadTarget(openpal::RSlice&, Analog&);
  static bool WriteTarget(const Analog&, openpal::WSlice&);
  static DNP3Serializer<Analog> Inst() { return DNP3Serializer<Analog>(ID(), Size(), &ReadTarget, &WriteTarget); }
};


struct Group32Var7
{
  static GroupVariationID ID() { return GroupVariationID(32,7); }

  Group32Var7();

  static uint32_t Size() { return 11; }
  static bool Read(openpal::RSlice&, Group32Var7&);
  static bool Write(const Group32Var7&, openpal::WSlice&);

  typedef float ValueType;
  uint8_t flags;
  float value;
  DNPTime time;

  typedef Analog Target;
  typedef AnalogSpec Spec;
  static bool ReadTarget(openpal::RSlice&, Analog&);
  static bool WriteTarget(const Analog&, openpal::WSlice&);
  static DNP3Serializer<Analog> Inst() { return DNP3Serializer<Analog>(ID(), Size(), &ReadTarget, &WriteTarget); }
};


struct Group32Var8
{
  static GroupVariationID ID() { return GroupVariationID(32,8); }

  Group32Var8();

  static uint32_t Size() { return 15; }
  static bool Read(openpal::RSlice&, Group32Var8&);
  static bool Write(const Group32Var8&, openpal::WSlice&);

  typedef double ValueType;
  uint8_t flags;
  double value;
  DNPTime time;

  typedef Analog Target;
  typedef AnalogSpec Spec;
  static bool ReadTarget(openpal::RSlice&, Analog&);
  static bool WriteTarget(const Analog&, openpal::WSlice&);
  static DNP3Serializer<Analog> Inst() { return DNP3Serializer<Analog>(ID(), Size(), &ReadTarget, &WriteTarget); }
};


}
# 29 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/cpp/libs/src/opendnp3/outstation/EventWriter.cpp" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/objects/Group42.h" 1
# 31 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/objects/Group42.h"
namespace opendnp3 {


struct Group42Var0
{
  static GroupVariationID ID() { return GroupVariationID(42,0); }
};


struct Group42Var1
{
  static GroupVariationID ID() { return GroupVariationID(42,1); }

  Group42Var1();

  static uint32_t Size() { return 5; }
  static bool Read(openpal::RSlice&, Group42Var1&);
  static bool Write(const Group42Var1&, openpal::WSlice&);

  typedef int32_t ValueType;
  uint8_t flags;
  int32_t value;

  typedef AnalogOutputStatus Target;
  typedef AnalogOutputStatusSpec Spec;
  static bool ReadTarget(openpal::RSlice&, AnalogOutputStatus&);
  static bool WriteTarget(const AnalogOutputStatus&, openpal::WSlice&);
  static DNP3Serializer<AnalogOutputStatus> Inst() { return DNP3Serializer<AnalogOutputStatus>(ID(), Size(), &ReadTarget, &WriteTarget); }
};


struct Group42Var2
{
  static GroupVariationID ID() { return GroupVariationID(42,2); }

  Group42Var2();

  static uint32_t Size() { return 3; }
  static bool Read(openpal::RSlice&, Group42Var2&);
  static bool Write(const Group42Var2&, openpal::WSlice&);

  typedef int16_t ValueType;
  uint8_t flags;
  int16_t value;

  typedef AnalogOutputStatus Target;
  typedef AnalogOutputStatusSpec Spec;
  static bool ReadTarget(openpal::RSlice&, AnalogOutputStatus&);
  static bool WriteTarget(const AnalogOutputStatus&, openpal::WSlice&);
  static DNP3Serializer<AnalogOutputStatus> Inst() { return DNP3Serializer<AnalogOutputStatus>(ID(), Size(), &ReadTarget, &WriteTarget); }
};


struct Group42Var3
{
  static GroupVariationID ID() { return GroupVariationID(42,3); }

  Group42Var3();

  static uint32_t Size() { return 11; }
  static bool Read(openpal::RSlice&, Group42Var3&);
  static bool Write(const Group42Var3&, openpal::WSlice&);

  typedef int32_t ValueType;
  uint8_t flags;
  int32_t value;
  DNPTime time;

  typedef AnalogOutputStatus Target;
  typedef AnalogOutputStatusSpec Spec;
  static bool ReadTarget(openpal::RSlice&, AnalogOutputStatus&);
  static bool WriteTarget(const AnalogOutputStatus&, openpal::WSlice&);
  static DNP3Serializer<AnalogOutputStatus> Inst() { return DNP3Serializer<AnalogOutputStatus>(ID(), Size(), &ReadTarget, &WriteTarget); }
};


struct Group42Var4
{
  static GroupVariationID ID() { return GroupVariationID(42,4); }

  Group42Var4();

  static uint32_t Size() { return 9; }
  static bool Read(openpal::RSlice&, Group42Var4&);
  static bool Write(const Group42Var4&, openpal::WSlice&);

  typedef int16_t ValueType;
  uint8_t flags;
  int16_t value;
  DNPTime time;

  typedef AnalogOutputStatus Target;
  typedef AnalogOutputStatusSpec Spec;
  static bool ReadTarget(openpal::RSlice&, AnalogOutputStatus&);
  static bool WriteTarget(const AnalogOutputStatus&, openpal::WSlice&);
  static DNP3Serializer<AnalogOutputStatus> Inst() { return DNP3Serializer<AnalogOutputStatus>(ID(), Size(), &ReadTarget, &WriteTarget); }
};


struct Group42Var5
{
  static GroupVariationID ID() { return GroupVariationID(42,5); }

  Group42Var5();

  static uint32_t Size() { return 5; }
  static bool Read(openpal::RSlice&, Group42Var5&);
  static bool Write(const Group42Var5&, openpal::WSlice&);

  typedef float ValueType;
  uint8_t flags;
  float value;

  typedef AnalogOutputStatus Target;
  typedef AnalogOutputStatusSpec Spec;
  static bool ReadTarget(openpal::RSlice&, AnalogOutputStatus&);
  static bool WriteTarget(const AnalogOutputStatus&, openpal::WSlice&);
  static DNP3Serializer<AnalogOutputStatus> Inst() { return DNP3Serializer<AnalogOutputStatus>(ID(), Size(), &ReadTarget, &WriteTarget); }
};


struct Group42Var6
{
  static GroupVariationID ID() { return GroupVariationID(42,6); }

  Group42Var6();

  static uint32_t Size() { return 9; }
  static bool Read(openpal::RSlice&, Group42Var6&);
  static bool Write(const Group42Var6&, openpal::WSlice&);

  typedef double ValueType;
  uint8_t flags;
  double value;

  typedef AnalogOutputStatus Target;
  typedef AnalogOutputStatusSpec Spec;
  static bool ReadTarget(openpal::RSlice&, AnalogOutputStatus&);
  static bool WriteTarget(const AnalogOutputStatus&, openpal::WSlice&);
  static DNP3Serializer<AnalogOutputStatus> Inst() { return DNP3Serializer<AnalogOutputStatus>(ID(), Size(), &ReadTarget, &WriteTarget); }
};


struct Group42Var7
{
  static GroupVariationID ID() { return GroupVariationID(42,7); }

  Group42Var7();

  static uint32_t Size() { return 11; }
  static bool Read(openpal::RSlice&, Group42Var7&);
  static bool Write(const Group42Var7&, openpal::WSlice&);

  typedef float ValueType;
  uint8_t flags;
  float value;
  DNPTime time;

  typedef AnalogOutputStatus Target;
  typedef AnalogOutputStatusSpec Spec;
  static bool ReadTarget(openpal::RSlice&, AnalogOutputStatus&);
  static bool WriteTarget(const AnalogOutputStatus&, openpal::WSlice&);
  static DNP3Serializer<AnalogOutputStatus> Inst() { return DNP3Serializer<AnalogOutputStatus>(ID(), Size(), &ReadTarget, &WriteTarget); }
};


struct Group42Var8
{
  static GroupVariationID ID() { return GroupVariationID(42,8); }

  Group42Var8();

  static uint32_t Size() { return 15; }
  static bool Read(openpal::RSlice&, Group42Var8&);
  static bool Write(const Group42Var8&, openpal::WSlice&);

  typedef double ValueType;
  uint8_t flags;
  double value;
  DNPTime time;

  typedef AnalogOutputStatus Target;
  typedef AnalogOutputStatusSpec Spec;
  static bool ReadTarget(openpal::RSlice&, AnalogOutputStatus&);
  static bool WriteTarget(const AnalogOutputStatus&, openpal::WSlice&);
  static DNP3Serializer<AnalogOutputStatus> Inst() { return DNP3Serializer<AnalogOutputStatus>(ID(), Size(), &ReadTarget, &WriteTarget); }
};


}
# 30 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/cpp/libs/src/opendnp3/outstation/EventWriter.cpp" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/objects/Group51.h" 1
# 29 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/objects/Group51.h"
namespace opendnp3 {


struct Group51Var1
{
  static GroupVariationID ID() { return GroupVariationID(51,1); }

  Group51Var1();

  static uint32_t Size() { return 6; }
  static bool Read(openpal::RSlice&, Group51Var1&);
  static bool Write(const Group51Var1&, openpal::WSlice&);

  DNPTime time;
};


struct Group51Var2
{
  static GroupVariationID ID() { return GroupVariationID(51,2); }

  Group51Var2();

  static uint32_t Size() { return 6; }
  static bool Read(openpal::RSlice&, Group51Var2&);
  static bool Write(const Group51Var2&, openpal::WSlice&);

  DNPTime time;
};


}
# 31 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/cpp/libs/src/opendnp3/outstation/EventWriter.cpp" 2
# 1 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/objects/Group122.h" 1
# 31 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/./cpp/libs/src/opendnp3/objects/Group122.h"
namespace opendnp3 {


struct Group122Var0
{
  static GroupVariationID ID() { return GroupVariationID(122,0); }
};


struct Group122Var1
{
  static GroupVariationID ID() { return GroupVariationID(122,1); }

  Group122Var1();

  static uint32_t Size() { return 7; }
  static bool Read(openpal::RSlice&, Group122Var1&);
  static bool Write(const Group122Var1&, openpal::WSlice&);

  typedef uint32_t ValueType;
  uint8_t flags;
  uint16_t assocId;
  uint32_t value;

  typedef SecurityStat Target;
  typedef SecurityStatSpec Spec;
  static bool ReadTarget(openpal::RSlice&, SecurityStat&);
  static bool WriteTarget(const SecurityStat&, openpal::WSlice&);
  static DNP3Serializer<SecurityStat> Inst() { return DNP3Serializer<SecurityStat>(ID(), Size(), &ReadTarget, &WriteTarget); }
};


struct Group122Var2
{
  static GroupVariationID ID() { return GroupVariationID(122,2); }

  Group122Var2();

  static uint32_t Size() { return 13; }
  static bool Read(openpal::RSlice&, Group122Var2&);
  static bool Write(const Group122Var2&, openpal::WSlice&);

  typedef uint32_t ValueType;
  uint8_t flags;
  uint16_t assocId;
  uint32_t value;
  DNPTime time;

  typedef SecurityStat Target;
  typedef SecurityStatSpec Spec;
  static bool ReadTarget(openpal::RSlice&, SecurityStat&);
  static bool WriteTarget(const SecurityStat&, openpal::WSlice&);
  static DNP3Serializer<SecurityStat> Inst() { return DNP3Serializer<SecurityStat>(ID(), Size(), &ReadTarget, &WriteTarget); }
};


}
# 32 "/opt/PLC/OpenPLC_v3/utils/dnp3_src/cpp/libs/src/opendnp3/outstation/EventWriter.cpp" 2

using namespace openpal;

namespace opendnp3
{
bool EventWriter::Write(HeaderWriter& writer, IEventRecorder& recorder, openpal::LinkedListIterator<SOERecord> iterator)
{
 while (iterator.HasNext() && recorder.HasMoreUnwrittenEvents())
 {
  auto pCurrent = iterator.Next();

  if (IsWritable(pCurrent->value))
  {
   auto result = LoadHeader(writer, recorder, pCurrent);
   iterator = result.location;

   if (result.isFragmentFull)
   {
    return false;
   }
  }
 }

 return true;
}

EventWriter::Result EventWriter::LoadHeader(HeaderWriter& writer, IEventRecorder& recorder, openpal::ListNode<SOERecord>* pLocation)
{
 switch (pLocation->value.type)
 {
 case(EventType::Binary) :
  return LoadHeaderBinary(writer, recorder, pLocation);
 case(EventType::DoubleBitBinary) :
  return LoadHeaderDoubleBinary(writer, recorder, pLocation);
 case(EventType::Counter):
  return LoadHeaderCounter(writer, recorder, pLocation);
 case(EventType::FrozenCounter):
  return LoadHeaderFrozenCounter(writer, recorder, pLocation);
 case(EventType::Analog):
  return LoadHeaderAnalog(writer, recorder, pLocation);
 case(EventType::BinaryOutputStatus):
  return LoadHeaderBinaryOutputStatus(writer, recorder, pLocation);
 case(EventType::AnalogOutputStatus) :
  return LoadHeaderAnalogOutputStatus(writer, recorder, pLocation);
 case(EventType::SecurityStat) :
  return LoadHeaderSecurityStat(writer, recorder, pLocation);
 default:
  return Result(false, LinkedListIterator<SOERecord>::Undefined());
 }
}

EventWriter::Result EventWriter::LoadHeaderBinary(HeaderWriter& writer, IEventRecorder& recorder, openpal::ListNode<SOERecord>* pLocation)
{
 auto variation = pLocation->value.GetValue<BinarySpec>().selectedVariation;

 switch (variation)
 {
 case(EventBinaryVariation::Group2Var1):
  return WriteTypeWithSerializer<BinarySpec>(writer, recorder, pLocation, Group2Var1::Inst(), variation);
 case(EventBinaryVariation::Group2Var2):
  return WriteTypeWithSerializer<BinarySpec>(writer, recorder, pLocation, Group2Var2::Inst(), variation);
 case(EventBinaryVariation::Group2Var3) :
  return WriteCTOTypeWithSerializer<BinarySpec, Group51Var1>(writer, recorder, pLocation, Group2Var3::Inst(), variation);
 default:
  return WriteTypeWithSerializer<BinarySpec>(writer, recorder, pLocation, Group2Var1::Inst(), variation);
 }
}

EventWriter::Result EventWriter::LoadHeaderDoubleBinary(HeaderWriter& writer, IEventRecorder& recorder, openpal::ListNode<SOERecord>* pLocation)
{
 auto variation = pLocation->value.GetValue<DoubleBitBinarySpec>().selectedVariation;

 switch (variation)
 {
 case(EventDoubleBinaryVariation::Group4Var1) :
  return WriteTypeWithSerializer<DoubleBitBinarySpec>(writer, recorder, pLocation, Group4Var1::Inst(), variation);
 case(EventDoubleBinaryVariation::Group4Var2) :
  return WriteTypeWithSerializer<DoubleBitBinarySpec>(writer, recorder, pLocation, Group4Var2::Inst(), variation);
 case(EventDoubleBinaryVariation::Group4Var3) :
  return WriteCTOTypeWithSerializer<DoubleBitBinarySpec, Group51Var1>(writer, recorder, pLocation, Group4Var3::Inst(), variation);
 default:
  return WriteTypeWithSerializer<DoubleBitBinarySpec>(writer, recorder, pLocation, Group4Var1::Inst(), variation);
 }
}

EventWriter::Result EventWriter::LoadHeaderCounter(HeaderWriter& writer, IEventRecorder& recorder, openpal::ListNode<SOERecord>* pLocation)
{
 auto variation = pLocation->value.GetValue<CounterSpec>().selectedVariation;

 switch (variation)
 {
 case(EventCounterVariation::Group22Var1) :
  return WriteTypeWithSerializer<CounterSpec>(writer, recorder, pLocation, Group22Var1::Inst(), variation);
 case(EventCounterVariation::Group22Var2) :
  return WriteTypeWithSerializer<CounterSpec>(writer, recorder, pLocation, Group22Var2::Inst(), variation);
 case(EventCounterVariation::Group22Var5) :
  return WriteTypeWithSerializer<CounterSpec>(writer, recorder, pLocation, Group22Var5::Inst(), variation);
 case(EventCounterVariation::Group22Var6) :
  return WriteTypeWithSerializer<CounterSpec>(writer, recorder, pLocation, Group22Var6::Inst(), variation);
 default:
  return WriteTypeWithSerializer<CounterSpec>(writer, recorder, pLocation, Group22Var1::Inst(), variation);
 }
}

EventWriter::Result EventWriter::LoadHeaderFrozenCounter(HeaderWriter& writer, IEventRecorder& recorder, openpal::ListNode<SOERecord>* pLocation)
{
 auto variation = pLocation->value.GetValue<FrozenCounterSpec>().selectedVariation;

 switch (variation)
 {
 case(EventFrozenCounterVariation::Group23Var1) :
  return WriteTypeWithSerializer<FrozenCounterSpec>(writer, recorder, pLocation, Group23Var1::Inst(), variation);
 case(EventFrozenCounterVariation::Group23Var2) :
  return WriteTypeWithSerializer<FrozenCounterSpec>(writer, recorder, pLocation, Group23Var2::Inst(), variation);
 case(EventFrozenCounterVariation::Group23Var5) :
  return WriteTypeWithSerializer<FrozenCounterSpec>(writer, recorder, pLocation, Group23Var5::Inst(), variation);
 case(EventFrozenCounterVariation::Group23Var6) :
  return WriteTypeWithSerializer<FrozenCounterSpec>(writer, recorder, pLocation, Group23Var6::Inst(), variation);
 default:
  return WriteTypeWithSerializer<FrozenCounterSpec>(writer, recorder, pLocation, Group23Var1::Inst(), variation);
 }
}

EventWriter::Result EventWriter::LoadHeaderAnalog(HeaderWriter& writer, IEventRecorder& recorder, openpal::ListNode<SOERecord>* pLocation)
{
 auto variation = pLocation->value.GetValue<AnalogSpec>().selectedVariation;

 switch (variation)
 {
 case(EventAnalogVariation::Group32Var1) :
  return WriteTypeWithSerializer<AnalogSpec>(writer, recorder, pLocation, Group32Var1::Inst(), variation);
 case(EventAnalogVariation::Group32Var2) :
  return WriteTypeWithSerializer<AnalogSpec>(writer, recorder, pLocation, Group32Var2::Inst(), variation);
 case(EventAnalogVariation::Group32Var3) :
  return WriteTypeWithSerializer<AnalogSpec>(writer, recorder, pLocation, Group32Var3::Inst(), variation);
 case(EventAnalogVariation::Group32Var4) :
  return WriteTypeWithSerializer<AnalogSpec>(writer, recorder, pLocation, Group32Var4::Inst(), variation);
 case(EventAnalogVariation::Group32Var5) :
  return WriteTypeWithSerializer<AnalogSpec>(writer, recorder, pLocation, Group32Var5::Inst(), variation);
 case(EventAnalogVariation::Group32Var6) :
  return WriteTypeWithSerializer<AnalogSpec>(writer, recorder, pLocation, Group32Var6::Inst(), variation);
 case(EventAnalogVariation::Group32Var7) :
  return WriteTypeWithSerializer<AnalogSpec>(writer, recorder, pLocation, Group32Var7::Inst(), variation);
 case(EventAnalogVariation::Group32Var8) :
  return WriteTypeWithSerializer<AnalogSpec>(writer, recorder, pLocation, Group32Var8::Inst(), variation);
 default:
  return WriteTypeWithSerializer<AnalogSpec>(writer, recorder, pLocation, Group32Var1::Inst(), variation);
 }
}

EventWriter::Result EventWriter::LoadHeaderBinaryOutputStatus(HeaderWriter& writer, IEventRecorder& recorder, openpal::ListNode<SOERecord>* pLocation)
{
 auto variation = pLocation->value.GetValue<BinaryOutputStatusSpec>().selectedVariation;

 switch (variation)
 {
 case(EventBinaryOutputStatusVariation::Group11Var1) :
  return WriteTypeWithSerializer<BinaryOutputStatusSpec>(writer, recorder, pLocation, Group11Var1::Inst(), variation);
 case(EventBinaryOutputStatusVariation::Group11Var2) :
  return WriteTypeWithSerializer<BinaryOutputStatusSpec>(writer, recorder, pLocation, Group11Var2::Inst(), variation);
 default:
  return WriteTypeWithSerializer<BinaryOutputStatusSpec>(writer, recorder, pLocation, Group11Var1::Inst(), variation);
 }
}

EventWriter::Result EventWriter::LoadHeaderAnalogOutputStatus(HeaderWriter& writer, IEventRecorder& recorder, openpal::ListNode<SOERecord>* pLocation)
{
 auto variation = pLocation->value.GetValue<AnalogOutputStatusSpec>().selectedVariation;

 switch (variation)
 {
 case(EventAnalogOutputStatusVariation::Group42Var1) :
  return WriteTypeWithSerializer<AnalogOutputStatusSpec>(writer, recorder, pLocation, Group42Var1::Inst(), variation);
 case(EventAnalogOutputStatusVariation::Group42Var2) :
  return WriteTypeWithSerializer<AnalogOutputStatusSpec>(writer, recorder, pLocation, Group42Var2::Inst(), variation);
 case(EventAnalogOutputStatusVariation::Group42Var3) :
  return WriteTypeWithSerializer<AnalogOutputStatusSpec>(writer, recorder, pLocation, Group42Var3::Inst(), variation);
 case(EventAnalogOutputStatusVariation::Group42Var4) :
  return WriteTypeWithSerializer<AnalogOutputStatusSpec>(writer, recorder, pLocation, Group42Var4::Inst(), variation);
 case(EventAnalogOutputStatusVariation::Group42Var5) :
  return WriteTypeWithSerializer<AnalogOutputStatusSpec>(writer, recorder, pLocation, Group42Var5::Inst(), variation);
 case(EventAnalogOutputStatusVariation::Group42Var6) :
  return WriteTypeWithSerializer<AnalogOutputStatusSpec>(writer, recorder, pLocation, Group42Var6::Inst(), variation);
 case(EventAnalogOutputStatusVariation::Group42Var7) :
  return WriteTypeWithSerializer<AnalogOutputStatusSpec>(writer, recorder, pLocation, Group42Var7::Inst(), variation);
 case(EventAnalogOutputStatusVariation::Group42Var8) :
  return WriteTypeWithSerializer<AnalogOutputStatusSpec>(writer, recorder, pLocation, Group42Var8::Inst(), variation);
 default:
  return WriteTypeWithSerializer<AnalogOutputStatusSpec>(writer, recorder, pLocation, Group42Var1::Inst(), variation);
 }
}

EventWriter::Result EventWriter::LoadHeaderSecurityStat(HeaderWriter& writer, IEventRecorder& recorder, openpal::ListNode<SOERecord>* pLocation)
{
 auto variation = pLocation->value.GetValue<SecurityStatSpec>().selectedVariation;

 switch (variation)
 {
 case(EventSecurityStatVariation::Group122Var1) :
  return WriteTypeWithSerializer<SecurityStatSpec>(writer, recorder, pLocation, Group122Var1::Inst(), variation);
 case(EventSecurityStatVariation::Group122Var2) :
  return WriteTypeWithSerializer<SecurityStatSpec>(writer, recorder, pLocation, Group122Var2::Inst(), variation);
 default:
  return WriteTypeWithSerializer<SecurityStatSpec>(writer, recorder, pLocation, Group122Var1::Inst(), variation);
 }
}

}
